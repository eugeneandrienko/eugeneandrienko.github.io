#+BEGIN_EXPORT html
---
layout: post
title: How I wrote an Emacs plugin to build my blog
category: it
date: 2024-12-01
lang: en
comments: false
hidden:
  - related_posts
image: /assets/static/emacs-plugin-jekyll-blog-header.png
banner:
  image: /assets/static/emacs-plugin-jekyll-blog-header.png
  opacity: 0.6
summary: Emacs Lisp program that makes it easy to build a Jekyll blog from org files
tags: emacs
---
#+END_EXPORT

* TOC                                                            :TOC_2_blog:
- [[* Introduction][Introduction]]
- [[* First version of OrgMode to HTML translator][First version of OrgMode to HTML translator]]
- [[* Jekyll-blog generation with Emacs Lisp][Jekyll-blog generation with Emacs Lisp]]
  - [[* Org to HTML conversion][Org to HTML conversion]]
  - [[* Custom function to copy files in temporary catalog][Custom function to copy files in temporary catalog]]
  - [[* HTML files patching][HTML files patching]]
  - [[* Static files export][Static files export]]
  - [[* Call Jekyll from Emacs][Call Jekyll from Emacs]]
  - [[* New blogpost creation][New blogpost creation]]
  - [[* Local server start][Local server start]]
  - [[* Jekyll's working directory cleanup][Jekyll's working directory cleanup]]
  - [[* UI (transient)][UI (transient)]]
  - [[* Emacs plugin specific code][Emacs plugin specific code]]
  - [[* Loading plugin in Emacs][Loading plugin in Emacs]]
- [[* Source code][Source code]]
- [[* What else could be improved?][What else could be improved?]]
- [[* Notes][Notes]]

* Introduction
:PROPERTIES:
:CUSTOM_ID: preface
:END:

In this post I'll tell you about my little Emacs plugin, that makes it easy to
work with a blog, built on top of a static site engine. It is possible to
write posts on OrgMode, although the almost all static site generators support
only Markdown, rarely reStructuredText, or HTMLüåö.

I used a lot of things:
- Wrote my blog in LiveJournal
- Self-hosted Wordpress blog on top of LAMP
- Wrote blog in Blogger.com
- Self-hosted my blog again. In this iteration, it was built using the Pelican
  static-site generator. Comments were added using Disqus.
- Tried [[https://hackage.haskell.org/package/pencil][pencil]]
- and so on...

In the end, I was tired of administering Apache/Nginx, MySQL/PostgreSQL,
php-fpm and so on. Also, I was also tired of useless WYSIWYG editors and
unnecessary "updates" of blogging platforms. Almost at that time, various
"virtue signaling" came on the scene¬†‚Äî and because of that I
lost[fn:virtue_signaling] my VPS (it provides the clear access to the Internet
for me¬†‚Äî like before, in the 1990s and 2000s, when were the really global
network with possibility to communicate with different people around the
world, without the censorship, GeoIP blocks and DPI). Also, I almost lost my
domain name[fn:namecheap].

As a result I stared using [[https://jekyllrb.com/][Jekyll]][fn:jekyll]. Now, the copy of my blog, with
all HTML and CSS files, is stored on my computer, independent of third-party
CDN, libraries and other stuff, to which I can lose access at any moment. I
"slightly" modified the [[https://github.com/jeffreytse/jekyll-theme-yat][Yat]] theme, to remove JavaScript from
it[fn:javascript], and loading of third-party resources from CDN. The only
remaining dependency¬†‚Äî from the Jekyll itself, and from it's plugins. But this
stuff is already on my hard drive and it's not going anywhere (don't forget
about backups!).

I also thought about how to achieve the next things:
1. My blog post sources should not be tightly coupled with a static site
   generator. I should be able to switch from one generator to another,
   without much pain. Or even write my own generator. This should be usable if
   Jekyll developers /suddenly/ decide to [[https://en.wikipedia.org/wiki/Discrimination_based_on_nationality][discriminate people by nationality or
   location]].
2. My blog should not be tightly coupled to a foreign infrastructure. One
   dependency I still can't get rid of is the dependency on domain name
   registar. For now, I can only evade registars, who discriminate clients or
   who work under the jurisdiction of my current place of residence.

   To host static blog¬†‚Äî any microwave oven can be used, if it is placed in
   the right place¬†‚Äî in a place where where the connectivity of the global
   network is not destroyed/destroing.
3. I'll be able to edit blog posts my way¬†‚Äî in Emacs with OrgMode. Not in a
   WYSIWYG online editor or forced to use the Markdown markup language.
4. I'll be able to use my catalog structure to store blog post source, images
   and other related files.

If I can't solve item #2 with some Emacs Lisp code, then over items can be
solved this way.

* First version of OrgMode to HTML translator
:PROPERTIES:
:CUSTOM_ID: generator-first-version
:END:

First version of OrgMode to HTML translator was based on the bash, sed, pandoc
and my own Java filter for pandoc. I used it for almost a year.

All my posts that were processed by this translator were in the =articles/=
directory. Each post was stored in its own subdirectory:

#+begin_example
rsync/blog (master) % tree --noreport articles
articles/
‚îú‚îÄ‚îÄ arms/
‚îú‚îÄ‚îÄ cycling/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2020-05-17-thanks-for-living/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ article-ru.org
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hate of car drivers.jpg
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ kamennoostrovskii.jpg
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ trollface.jpg
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ truck.gif
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ ushakovski most.jpg
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2021-04-08-vk-cyclist-types/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ article-ru.org
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hate of car drivers.jpg
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ usual-seat-as-urbanist-thinks.jpg
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ usual-seat.jpg
‚îú‚îÄ‚îÄ it/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2020-09-09-thinkpad-x220-freebsd/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ article-en.org
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ article-ru.org
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ freebsd_intel_glitches.jpg
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2023-12-20-plain-text-accounting/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2024-01-02-life-in-console/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2024-07-07-thinkpad-x220-second-life/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2024-10-27-freebsd-bhyve-windows/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 2024-11-09-emacs-plugin-jekyll-blog/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ draft-palm-tung-e2-archaeological/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 20231223_141710.jpg
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 20231223_142550.jpg
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 20231230_200500.jpg
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 20231231_144949.jpg
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 20231231_205901.jpg
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 20240101_162620.jpg
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 20240101_215815.jpg
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 20240101_215908.jpg
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ article-ru.org
‚îú‚îÄ‚îÄ leatherwork/
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 2021-01-29-leatherwork-useful-links/
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ article-ru.org
‚îî‚îÄ‚îÄ photo/
#+end_example

Today I still use this tree-like structure. It allows to see all related to
blog post files in one catalog. Also, I'm able to open an org-file with
blogpost text in Emacs and will see text almost as it will be in the blog
itself:

#+CAPTION: Blogpost text, opened in Emacs
#+ATTR_HTML: :align center :alt Post's draft, opened in Emacs
[[file:emacs-blog-post.png]]

Inside the catalog with the blog files there was a special =Makefile= that
executed /the special/ bash script. This script scanned the =articles/= catalog
and put the found blogpost files to the next conveyor:

#+BEGIN_SRC plantuml :exports none :file first_generator.png
@startuml
!theme sunlust
skinparam handwritten true
scale 2.2

title Org2HTML conveyor

() "OrgMode files" as OrgModeSrc
() "HTML files" as HtmlFiles
package "Makefile" {
  package "Shell script" {
    [sed] as sed1
    OrgModeSrc - sed1
    note right of sed1 : Fixes links to static files
    sed1 ..> [awk] : Patched OrgMode files
    note left of [awk] : Inserts language code to header
    [pandoc] as pandoc1
    [awk] ..> pandoc1 : Patched OrgMode files
    note right of pandoc1 : Translates OrgMode to AST
    pandoc1 ..> [Java filter] : AST
    note left of [Java filter]
      Inserts language code to
      proper place, inserts
      path to banner image
      and summary
    end note
    [pandoc] as pandoc2
    note right of pandoc2 : Translates AST to Markdown
    [Java filter] ..> pandoc2 : Patched AST
    [sed] as sed2
    note left of sed2 : Fixes titles in generated files
    pandoc2 ..> sed2 : Markdown files
  }
  sed2 ..> [bundle exec jekyll build] : Patched Markdown files
}
[bundle exec jekyll build] - HtmlFiles

footer //First and obsolete version, not in use!//
@enduml
#+END_SRC

#+CAPTION: Conveyor for OrgMode to HTML transformation
#+ATTR_HTML: :align center :alt Conveyor for Org2HTML transformation
[[file:first_generator.png]]

You can see the code of this conveyor [[https://github.com/eugeneandrienko/eugeneandrienko.github.io/blob/3b70ec4997a063fdd3c1bf4c23c3c9a5d78b78e3/README.org][in the next commit]], in the =README.org=
file. Source code for pandoc's Java filter [[https://github.com/eugeneandrienko/pandoc_jekyll][is in a separate repository]].

Obviously it was overcomplicated. It will be much simpler if the resulting
HTML file is generated by OrgMode functions, without unnecessary additional
transformations. By the way, there are a lot of functions in OrgMode to
convert org-files into different formats.

At that time I found [[https://mastodon.social/@fabrik42][Christian Dewein's]] article in Mastodon: [[https://christiandewein.com/publishing-with-jekyll-emacs-org-mode][Publishing on the
web with Jekyll, Emacs and Org-Mode]]...

* Jekyll-blog generation with Emacs Lisp
:PROPERTIES:
:CUSTOM_ID: emacs-lisp-jekyll-gen
:END:

As I realized, I can throw away my =sed= + =awk= + =pandoc= + =Java-—Ñ–∏–ª—å—Ç—Ä= conveyor
and replace it with a single call to the
=org-publish-project=[fn:org-publish-project] function. And Markdown‚áíHTML
conversion became unnecessary.

I had some experience in Lisp ~programming~ (I programmed few things with
Clojure[fn:clojure]). So I started to write my own plugin, using [[https://mastodon.social/@fabrik42][Christian
Dewein's]] code as a reference.

Emacs Lisp programming in Emacs is such a joy! You have a built-in help system
via =C-h f=, =C-h v= and so on. And you have a built-in REPL (=M-x ielm=). And you
already have a built-in debugger. I can calmly play with [[https://www.s-expressions.org/home][S-expressions]],
immediately check how it works in REPL, and build my program "brick by brick".

** Org to HTML conversion
:PROPERTIES:
:CUSTOM_ID: convert-org2html
:END:

The above-mentioned =org-publish-project= function is able to take files from a
specified catalog, convert them to a specified format and save new files to
another catalog. All =org-publish-project= settings are stored in the
=org-publish-project-alist= list.

For example, to convert org files from =~/test= to HTML files for Jekyll in
=~/results=, I can use the following code:

#+begin_src emacs-lisp
(let ((org-publish-project-alist `(("org-jekyll-org"
                                    :base-directory "~/test"
                                    :base-extension "org"
                                    :publishing-directory "~/results"
                                    :publishing-function org-html-publish-to-html
                                    :html-extension "html"
                                    :headline-levels 5
                                    :html-toplevel-hlevel 2
                                    :html-html5-fancy t
                                    :html-table-attributes (:border "2" :cellspacing "0" :cellpadding "6" :frame "void")
                                    :section-numbers nil
                                    :html-inline-images t
                                    :htmlized-source t
                                    :with-toc nil
                                    :with-sub-superscript nil
                                    :body-only t
                                    :recursive t))))
  (org-publish-project "org-jekyll-org" t nil))
#+end_src

Here are the next important parameters:
- =:base-directory= ‚Äî path to directory containing org files for export.
- =:base-extension= ‚Äî extension(s) for source files.
- ~:publishing-directory~ ‚Äî path to directory with export results.

There are some tweaks for HTML conversion in other parameters. I use it to get
HTML files suitable for use inside Jekyll.

It will be good to change some paths without editing the source code. To
achieve this, the =defcustom=[fn:defcustom] function from Emacs Lisp can be
used. This function allows you to describe the plugin's settings in a way that
they can be edited in generally accepted methods¬†‚Äî via =M-x customize= or via
the =:custom= section in the =use-package=:

#+CAPTION: M-x customize interface
#+ATTR_HTML: :align center :alt Emacs M-x customize
[[file:customize.png]]

I have described the path to catalog with blog and the path to catalog with
blog's articles in the next way:

#+begin_src emacs-lisp
(defgroup org-jekyll ()
  "Emacs mode to write on OrgMode for Jekyll blog."
  :group 'local
  :prefix "org-jekyll-"
  :link '(url-link :tag "Source code" "https://github.com/eugeneandrienko/eugeneandrienko.github.io"))

(defgroup org-jekyll-paths nil
  "Paths for emacs mode to write on OrgMode for Jekyll blog."
  :group 'org-jekyll
  :prefix "org-jekyll-paths-")

(defcustom org-jekyll-paths-base-path
  "~/rsync/blog"
  "Path to the base directory of my blog."
  :type 'directory
  :group 'org-jekyll-paths)

(defcustom org-jekyll-paths-articles-path
  (concat org-jekyll-paths-base-path "/articles")
  "Path to directory with original articles in Org format."
  :type 'directory
  :group 'org-jekyll-paths)
#+end_src

The first S-expression describes a new menu item in the Emacs settings. The
second S-expression creates a submenu item inside the previous menu
item. Inside the last item are two settings¬†‚Äî path to directory with blog and
path to blogpost source files.

As a result, the =org-publish-project= call from above can be rewritten in the
next way:

#+begin_src emacs-lisp
(let ((org-publish-project-alist `(("org-jekyll-org"
                                    :base-directory ,org-jekyll-paths-articles-path
                                    :base-extension "org"
                                    :publishing-directory ,(concat org-jekyll-paths-base-path "/_posts")
                                    :publishing-function org-html-publish-to-html
#+end_src

Here we have a special syntax for lists that contain executable code
inside. The normal list declaration can't evaluate the code inside:

#+begin_example
> '("a" (concat "b" "2") "c")

("a"
 (concat "b" "2")
 "c")
#+end_example

But when backquoting is used[fn:quoting], it becomes possible to include and
evaluate code within the list:

#+begin_example
> `("a" ,(concat "b" "2") "c")
("a" "b2" "c")
#+end_example

The aforementioned =org-publish-project= call is enough to convert org-files to
HTML in an ideal case. But, /in my case,/ I can't use it¬†‚Äî all my blogpost org
files are not stored in one catalog, but in separate subdirectories!

This means, that I need to call /a special, custom function/ before calling
=org-publish-project=. This /custom function/ should copy all the org files from
the subdirectories to the temporary directory for =org-publilsh-project=.

To call this /custom function/ before calling =org-publish-project= there is a
=:preparation-function= parameter:

#+begin_src emacs-lisp
(let ((org-publish-project-alist `(("org-jekyll-org"
                                    :base-directory ,(concat org-jekyll-paths-base-path "/_articles")
                                    :base-extension "org"
                                    :publishing-directory ,(concat org-jekyll-paths-base-path "/_posts")
                                    :preparation-function org-jekyll--prepare-articles
#+end_src

As you can see, here I change the =:base-directory= parameter to the path of the
temporary catalog containing the articles.

** Custom function to copy files in temporary catalog
:PROPERTIES:
:CUSTOM_ID: copy-2-tmp-catalog
:END:

First, I need to get a list of org-files with blogposts from =articles/=
catalog. This list can be returned with the
=directory-files-recursively=[fn:directory-files-recursively] function:

#+begin_src emacs-lisp
(directory-files-recursively org-jekyll-paths-articles-path "\\.org$" nil nil nil)

("~/rsync/blog/articles/cycling/2020-05-17-thanks-for-living/article-ru.org"
 "~/rsync/blog/articles/cycling/2021-04-08-vk-cyclist-types/article-ru.org"
 "~/rsync/blog/articles/cycling/2021-04-12-balticstar-north-open-2021/article-ru.org"
 "~/rsync/blog/articles/cycling/2021-05-17-insled-open/article-ru.org"
 "~/rsync/blog/articles/cycling/draft-osmand-howto/article-ru.org"
 "~/rsync/blog/articles/cycling/draft-qmapshack-howto/article-ru.org"
 ...
 "~/rsync/blog/articles/_post_template.org")
#+end_src

But there are a lot of unnecessary files in the result of this function¬†‚Äî
drafts, hidden posts and template. It can be filtered using
=seq-filter=[fn:seq-filter] function:

#+begin_src emacs-lisp
(seq-filter (lambda (path)
              (and
               (not (string-match org-jekyll-exclude-regex path))
               (not (string-match "\\(draft-\\)\\|\\(hidden-\\)" path))))
            (directory-files-recursively org-jekyll-paths-articles-path "\\.org$" nil nil nil))
#+end_src

This function removes items from the list (second parameter) that do not match
the predicate (first parameter) check(s). The predicate¬†‚Äî is just a lambda
function that checks whether the path is not a draft/hidden file or a template
file.

The =org-jekyll-exclude-regex= variable¬†‚Äî is just a regular expression to throw
away inappropriate paths:

#+begin_src emacs-lisp
(defcustom org-jekyll-exclude-regex
  "\\(_post_template\\.org\\)\\|\\(\\.project\\)"
  "Regex to exclude unwanted files."
  :type 'regexp
  :group 'org-jekyll)
#+end_src

Now we have /a right/ list of paths and should pass each element of it to copy
files function. This can be achieved with the =mapc=[fn:mapc] function, which
applies the lambda function from the first argument to each element of the
list that is passed as the seccond argument:

#+begin_src emacs-lisp
(mapc (lambda (article)
        (
         ;; copy file in `article' path here
         )
        (seq-filter (lambda (path)
              (and
               (not (string-match org-jekyll-exclude-regex path))
               (not (string-match "\\(draft-\\)\\|\\(hidden-\\)" path))))
                    (directory-files-recursively org-jekyll-paths-articles-path "\\.org$" nil nil nil))
#+end_src

I use path elements from =article= variable: date, URL and language
code[fn:lang_code]¬†‚Äî to create an unique filename for intermediate file. To
cut necessary chunks from string with path, the regexes with capturing groups
are used. For this purpose there are functions =string-match= and
=match-string=[fn:regex-search] in Emacs Lisp:

#+begin_src emacs-lisp
(string-match
 (concat org-jekyll-paths-articles-path
         "/\\(\\w+\\)/\\([0-9-]+\\)-\\([[:alnum:]-]+\\)/article-\\([[:lower:]]\\{2\\}\\)\\.org$")
 "~/rsync/blog/articles/photo/2024-09-01-summer-photos-2024/article-en.org")
0 (#o0, #x0, ?\C-@)

(match-string 1 "~/rsync/blog/articles/photo/2024-09-01-summer-photos-2024/article-en.org")
"photo"

(match-string 2 "~/rsync/blog/articles/photo/2024-09-01-summer-photos-2024/article-en.org")
"2024-09-01"

(match-string 3 "~/rsync/blog/articles/photo/2024-09-01-summer-photos-2024/article-en.org")
"summer-photos-2024"

(match-string 4 "~/rsync/blog/articles/photo/2024-09-01-summer-photos-2024/article-en.org")
"en"
#+end_src

Inside the lambda-function's code I wrap it all in =let*=[fn:let-star] for
simplicity:

#+begin_src emacs-lisp
(lambda (article)
          (progn
            (string-match
             (concat org-jekyll-paths-articles-path
                     "/\\(\\w+\\)/\\([0-9-]+\\)-\\([[:alnum:]-]+\\)/article-\\([[:lower:]]\\{2\\}\\)\\.org$")
             article)
            (let*
                ((article-category (match-string 1 article))
                 (article-date (match-string 2 article))
                 (article-slug (match-string 3 article))
                 (article-lang (match-string 4 article)))
              (
                                        ;copy-file-here
               )))
#+end_src

For convenience I'll add two more variables:
1. Variable with intermediate catalog name: path to =_articles/= +
   =article-lang=. Path to =_articles/= is accessible from ="org-jekyll-org"=
   project settings¬†‚Äî list with these settings is passed as single parameter
   to =org-jekyll--prepare-articles= function. By the name of parameter
   (=:base-directory=) the necessary value can be taken[fn:plist-get]:
   #+begin_src emacs-lisp
   (article-new-catalog (concat
                         (plist-get property-list ':base-directory)
                         "/"
                         article-lang))
   #+end_src
2. Variable with unique path to file containing blogpost in intermediate
   catalog:
   #+begin_src emacs-lisp
   (article-processed (concat article-new-catalog "/" article-date "-" article-slug ".org"))
   #+end_src

For example, if the =article= is equals to
=~/rsync/blog/articles/photo/2024-09-01-summer-photos-2024/article-en.org=, then
at the end of execution the =article-processed= variable is equal to:
=~/rsync/blog/_articles/en/2024-09-01-summer-photos-2024.org=.

Creating the new temporary catalog (if it does not already exists) and copying
the files can be done with the next two functions inside the =let*= body:

#+begin_src emacs-lisp
(make-directory article-new-catalog t)
(copy-file article article-processed t t t t)
#+end_src

The resulting code of ~org-jekyll--prepare-articles~ function:

#+begin_src emacs-lisp
(defun org-jekyll--prepare-articles (property-list)
  "Copy articles to `_articles/' catalog before publishing. Rename
article file from `article-LANG.org' to
`YYYY-MM-DD-short-url.org'.

PROPERTY-LIST is a list of properties from
`org-publish-project-alist'."
  (mapc (lambda (article)
          (progn
            (string-match
             (concat org-jekyll-paths-articles-path
                     "/\\(\\w+\\)/\\([0-9-]+\\)-\\([[:alnum:]-]+\\)/article-\\([[:lower:]]\\{2\\}\\)\\.org$")
             article)
            (let*
                ((article-category (match-string 1 article))
                 (article-date (match-string 2 article))
                 (article-slug (match-string 3 article))
                 (article-lang (match-string 4 article))
                 (article-new-catalog (concat
                                       (plist-get property-list ':base-directory)
                                       "/"
                                       article-lang))
                 (article-processed (concat article-new-catalog "/" article-date "-" article-slug ".org")))
              (make-directory article-new-catalog t)
              (copy-file article article-processed t t t t))))
        (seq-filter (lambda (path)
                      (and
                       (not (string-match org-jekyll-exclude-regex path))
                       (not (string-match "\\(draft-\\)\\|\\(hidden-\\)" path))))
                    (directory-files-recursively org-jekyll-paths-articles-path "\\.org$" nil nil nil))))
#+end_src

This function works good in tandem with ~org-publish-project~. But ... there are
broken links to images in the resulting HTML file. This happens, because in
the source file there are relative paths to images¬†‚Äî relative to the
subdirectory containing the blogpost files. And these paths are passed
unchanged to HTML.

But in Jekyll these static files exist in =/assets/static= catalog. Solution is
simple¬†‚Äî change paths inside copied temporary file after =copy-file= call. I
wrote a new function for this:

#+begin_src emacs-lisp
(defun org-jekyll--prepare-article (article)
  "Prepare article's text for Jekyll.

Modify OrgMode file before publish it. ARTICLE is a path to
OrgMode file with article. Files, stored in `_articles/' will be
modified, not original articles from `org-jekyll-paths-articles-path'
path.

ARTICLE is a path to intermediate org-file with article text"
  (with-temp-buffer
    (insert-file-contents article)
    (goto-char (point-min))
    (while (search-forward "[‚Äéfile:" nil t)
      (replace-match "[‚Äèfile://assets/static/" t t))
    (write-file article)))
#+end_src

This function simply takes the org file with the path from the =article=
variable and replaces links like =[f‚Äéile:somefile.ext]= with
=[f‚Äéile://assets/static/somefile.ext]=.

** HTML files patching
:PROPERTIES:
:CUSTOM_ID: html-file-editing
:END:

Unfortunately, =org-publish-project= inserts things into the HTML files that I
don't want to see:
- Randomly generated IDs in HTML tags
- Image numbering.
- Tag =:TOC_2_blog:= after ¬´TOC¬ª heading. This tag is needed in the OrgMode file
  to automatically generate the TOC with [[https://github.com/snosov1/toc-org/][toc-org]][fn:toc-org].
- Extra heading for annotations not in post language.

Solution is simple¬†‚Äî we need one another function to delete all unnecessary
stuff from HTML files with regular expressions. We can specify such function
in settings of =org-publish-project= to call it right after export to HTML is
completed (see parameter =:completion-function=).

The function itself is quite simple. First, we get the path to the catalog
containing the exported HTML files from =org-publish-project= settings. Next, we
get a list of paths to HTML files, which we pass to the lambda function:

#+begin_src emacs-lisp
(defun org-jekyll--complete-articles (property-list)
  "Change published html-files via regular expressions.

Fix links to attached files. Remove \"Footnotes:\" section from
generated file. Remove autogenerated Org ids from html tags.

PROPERTY-LIST is a list of properties from
`org-publish-project-alist'."
  (let*
      ((publishing-directory (plist-get property-list ':publishing-directory)))
    (mapc (lambda (html)
            ; process `html' file
            )
          (directory-files-recursively publishing-directory "\\.html$" nil nil nil))))
#+end_src

Inside this lambda function there is a =mapc= call what works with regular
expression list:

#+begin_src emacs-lisp
(mapc (lambda (x)
        (progn
          (goto-char (point-min))
          (while (re-search-forward (car x) nil t)
            (replace-match (cdr x) t nil))))
      '(("file://" . "/")
        ("<p><span class=\"figure-number\">[[:alnum:] :]+</span>\\(.+\\)</p>" . "<p style=\"text-align: center\"><i>\\1</i></p>")
        ("<h2 class=\"footnotes\">Footnotes: </h2>" . "")
        (" id=\"org[[:xdigit:]]\\{7\\}\"" . "")
        (" id=\"outline-container-org[[:xdigit:]]\\{7\\}\"" . "")
        (" id=\"text-org[[:xdigit:]]\\{7\\}\"" . "")
        ("<span class=\"TOC_2_blog\">TOC_2_blog</span>" . "")))
#+end_src

Here, each element of list is just another list of two elements. First element
is a regular expression to search for text to replace. Second element is some
replacement text. We retrieve these elements using =(car x)= and =(cdr x)=. The
text replacement is done using the standard Emacs Lisp functions for working
with regular expressions.

Resulting code of =org-jekyll--complete-articles=:

#+begin_src emacs-lisp
(defun org-jekyll--complete-articles (property-list)
  "Change published html-files via regular expressions.

Fix links to attached files. Remove \"Footnotes:\" section from
generated file. Remove autogenerated Org ids from html tags.

PROPERTY-LIST is a list of properties from
`org-publish-project-alist'."
  (let*
      ((publishing-directory (plist-get property-list ':publishing-directory)))
    (mapc (lambda (html)
            (with-temp-buffer
              (insert-file-contents html)
              (mapc (lambda (x)
                      (progn
                        (goto-char (point-min))
                        (while (re-search-forward (car x) nil t)
                          (replace-match (cdr x) t nil))))
                    '(("file://" . "/")
                      ("<p><span class=\"figure-number\">[[:alnum:] :]+</span>\\(.+\\)</p>" . "<p style=\"text-align: center\"><i>\\1</i></p>")
                      ("<h2 class=\"footnotes\">Footnotes: </h2>" . "")
                      (" id=\"org[[:xdigit:]]\\{7\\}\"" . "")
                      (" id=\"outline-container-org[[:xdigit:]]\\{7\\}\"" . "")
                      (" id=\"text-org[[:xdigit:]]\\{7\\}\"" . "")
                      ("<span class=\"TOC_2_blog\">TOC_2_blog</span>" . "")))
              (write-file html)))
          (directory-files-recursively publishing-directory "\\.html$" nil nil nil))))
#+end_src

** Static files export
:PROPERTIES:
:CUSTOM_ID: static-files-export
:END:

Obviously HTML files are not enough for a blog. Images and other attachments
are necessary too.

These files can also be copied with =org-publish-project= call. And the settings
are much easier in this case:

#+begin_src emacs-lisp
(let ((org-publish-project-alist `(("org-jekyll-static"
                                    :base-directory ,(concat org-jekyll-paths-base-path "/_static")
                                    :base-extension "jpg\\|JPG\\|jpeg\\|png\\|gif\\|webm\\|webp\\|gpx\\|tar.bz2\\|uxf"
                                    :publishing-directory ,(concat org-jekyll-paths-base-path "/assets/static")
                                    :publishing-function org-publish-attachment
                                    :preparation-function org-jekyll--prepare-static
                                    :exclude ,org-jekyll-exclude-regex
                                    :recursive t)))))
#+end_src

Here, the =:base-extension= parameter specifies extensions for exporting static
files.

Exporting HTML files and exporting static files can be combined under one
"project", to execute both tasks with one function call:

#+begin_src emacs-lisp
(let ((org-publish-project-alist `(("org-jekyll-org"
                                    ...)
                                   ("org-jekyll-static"
                                    ...)
                                   ("org-jekyll" :components ("org-jekyll-org" "org-jekyll-static")))))
  (org-publish-project "org-jekyll" t nil))
#+end_src


As you can see, we use another =:preparation-function= when copying static
files¬†‚Äî =org-jekyll--prepare-static=. This function works the same as
=org-jekyll--prepare-articles= ‚Äî it just copies static files from different
subdirectories to a temporary directory for the =org-jekyll-project= function.

#+begin_src emacs-lisp
(defun org-jekyll--prepare-static (property-list)
  "Copy static files to `/_static' directory.

PROPERTY-LIST is a list of properties from
`org-publish-project-alist'."
  (let
      ((static-directory (plist-get property-list `:base-directory)))
    (make-directory static-directory t)
    (mapc (lambda (filename)
            (progn
              (string-match (concat org-jekyll-paths-articles-path "/[[:alnum:]-/]+/\\([[:alnum:][:blank:]-_.]+\\)$") filename)
              (let
                  ((static-filename (match-string 1 filename)))
                (copy-file filename (concat static-directory "/" static-filename) t t t t))))
          (seq-filter (lambda (path)
                        (not (string-match
                              (concat org-jekyll-exclude-regex "\\|\\(article-[[:lower:]]+\\.org\\)")
                              path)))
                      (directory-files-recursively org-jekyll-paths-articles-path "." nil nil nil)))))
#+end_src

** Call Jekyll from Emacs
:PROPERTIES:
:CUSTOM_ID: jekyll-build-from-emacs
:END:

After we have prepared all necessary HTML and static files¬†‚Äî we should call
Jekyll to build our static blog inside =_site/= catalog. Usually, the console
command =bundle exec jekyll build= is used for this.

In [[https://mastodon.social/@fabrik42][Christian Dewein's]] article, the [[https://github.com/rejeep/prodigy.el][Prodigy]] plugin is used to call this console
command. I decided that this is too complicated and just execute a new process
using the =make-process=[fn:make-process] function:

#+begin_src emacs-lisp
(make-process
 :name "jekyll-build"
 :buffer "jekyll-build"
 :command '("bundle" "exec" "jekyll" "build")
 :delete-exited-processes t
 :sentinel (lambda (process state)
             (cond
              ((and (eq (process-status process) 'exit)
                    (zerop (process-exit-status process)))
               (message "%s" (propertize "Blog built" 'face '(:foreground "blue"))))
              ((eq (process-status process) 'run)
               (accept-process-output process))
              (t (error (concat "Jekyll Build: " state))))))
#+end_src

In this code, console command output is processed inside a lambda function,
which either prints message about successful execution or prints an error to
the user. User messages are printed to a minibuffer using the
=message=[fn:message] function, with text colored blue (coloring is done using
=propertize=[fn:propertize]):

#+ATTR_HTML: :align center :alt message function output
[[file:message.png]]

The output of the executed process is sent to the =jekyll-build= buffer. This
buffer is used to watch the build log, if necessary.

File export and =bundle exec= execution are combined in =org-jekyll--suffix-build=
function. This allows to build the static blog with single call of function.

Since the current directory for buffer with opened blog post is not an
=org-jekyll-path-base-path=, we should change directory before execute the build
process. After the build is finished, we should change the directory back to
continue editing the post.

#+begin_src emacs-lisp
(defun org-jekyll--suffix-build ()
  "Build the blog."
  (interactive)
  (cd (expand-file-name org-jekyll-paths-base-path))
  (let ((org-publish-project-alist `(("org-jekyll-org"
                                      ...)
                                     ("org-jekyll-static"
                                      ...)
                                     ("org-jekyll" :components ("org-jekyll-org" "org-jekyll-static"))))
        (current-path (file-name-directory buffer-file-name)))
    (cd (expand-file-name org-jekyll-paths-base-path))
    (org-publish-project "org-jekyll" t nil))
  (make-process
   :name "jekyll-build"
   :buffer "jekyll-build"
   :command '("bundle" "exec" "jekyll" "build")
   :delete-exited-processes t
   :sentinel (lambda (process state)
               ...))
  (cd current-path))
#+end_src

** New blogpost creation
:PROPERTIES:
:CUSTOM_ID: create-new-post
:END:

I wanted to have a special function to semi-automatically create new post. I
don't want to create a new subdirectory for the post in the appropriate
directory, copy Jekyll's frontmatter, image for the post banner, etc. It will
be very useful if Emacs asks me all the necessary questions and creates all
the necessary directories and files itself.

There are a lot of functions to work with user input in Emacs. But it is
enough for me to use the four simple functions:
- =read-string=: prompts the user in a minibuffer and returns the string,
  entered by the user.
- =completing-read=: prints menu to minibuffer and returns user's choice.
- =y-or-n-p=: prompts user in minibuffer and waits for user's "Yes" or "No"
  answer. Returns =t= or =nil=.
- =read-file-name=: outputs a file selection menu and returns the path to the
  selected file.

Quickly enough, I sketched out the following S-expressions, which ask
everything necessary and store the results in separate variables:

#+begin_src emacs-lisp
(let* ((category (completing-read "Enter category: "
                                  (seq-filter
                                   (lambda (category) (string-match "^[[:lower:]]+$" category))
                                   (directory-files org-jekyll-paths-articles-path nil
                                                    directory-files-no-dot-files-regexp
                                                    nil nil))
                                  nil t))
       (name (read-string "Enter title: "))
       (summary (read-string "Enter summary: "))
       (tags (read-string "Enter tags (space separated): "))
       (permalink (read-string "Enter permalink: "))
       (language (completing-read "Enter post language: " org-jekyll-languages nil t))
       (use-banner (y-or-n-p "Use banner?"))
       (banner (if use-banner
                   (read-file-name "Path to banner image: " nil nil t nil nil)
                 nil))))
#+end_src

#+CAPTION: New post creation UI
#+ATTR_HTML: :align center :alt new post creation UI
[[file:create_new_post.jpg]]

Within the same =let*= I compute:
- Part of the front matter with Jekyll's banner insertion code:
  #+begin_src emacs-lisp
  (additional (concat (if use-banner
                          (concat "image: /assets/static/" (file-name-nondirectory banner) "\n"
                                  "banner:\n"
                                  "  image: /assets/static/" (file-name-nondirectory banner) "\n"
                                  "  opacity: 0.6\n")
                        "")
                      (concat "summary: " summary "\n")
                      (concat "tags: " tags)))
  #+end_src
- Path to new post:
  #+begin_src emacs-lisp
  (dirname (concat path "/" category "/" date "-" permalink))
  #+end_src
- Post's filename¬†‚Äî concatenate =article= with entered language code:
  #+begin_src emacs-lisp
  (filename (concat dirname "/" "article-" language ".org"))
  #+end_src

After evaluating all variables, there are inside =let*= body:
1. Create subdirectory with files for new post:
   #+begin_src emacs-lisp
   (make-directory dirname t)
   #+end_src
2. If we chose to use banner image for post, then copy appropriate image to
   previously created directory:
   #+begin_src emacs-lisp
   (if use-banner
       (copy-file banner (concat dirname "/" (file-name-nondirectory banner))))
   #+end_src
3. Replace template placeholders in =org-jekyll-paths-template-path= path and
   save new file with =filename= name: {% raw %}
   #+begin_src emacs-lisp
   (with-temp-buffer
     (insert-file-contents template)
     (mapc
      (lambda (x) (progn
                    (goto-char (point-min))
                    (while (search-forward (car x) nil t)
                      (replace-match (cdr x) t t))))
      `(("{%NAME%}" . ,name)
        ("{%CATEGORY%}" . ,category)
        ("{%DATE%}" . ,date)
        ("{%LANG%}" . ,language)
        ("{%ADDITIONAL%}" . ,additional)))
     (write-file filename))
   #+end_src
   {% endraw %}
4. Previously created file is opened in current buffer and cursor is moved to
   the end of file:
   #+begin_src emacs-lisp
   (with-current-buffer (find-file filename)
     (goto-char (point-max)))
   #+end_src

Path to template stored in =org-jekyll-paths-template-path= variable (copied to
=template= variable inside =let*= for convenience):

#+begin_src emacs-lisp
(defcustom org-jekyll-paths-template-path
  (concat org-jekyll-paths-articles-path "/_post_template.org")
  "Path to post template."
  :type '(file :must-match t)
  :group 'org-jekyll-paths)
#+end_src

In my settings this variable is =~/rsync/blog/articles/_post_template.org=. The
file itself looks like this:

{% raw %}
#+begin_example
#+BEGIN_EXPORT html
---
layout: post
title: {%NAME%}
category: {%CATEGORY%}
date: {%DATE%}
lang: {%LANG%}
comments: false
hidden:
  - related_posts
{%ADDITIONAL%}
---
#+END_EXPORT


#+end_example
{% endraw %}

As you can see, there is only a Jekyll's front matter and nothing else.

** Local server start
:PROPERTIES:
:CUSTOM_ID: jekyll-local-server
:END:

For new, blog building and new post creation via Emacs Lisp is ready. Among
the most frequently used actions, I still have the local server startup and
the Jekyll's working directory cleanup.

Starting the local server is easy¬†‚Äî just call the =make-process= with the
necessary arguments:

#+begin_src emacs-lisp
(make-process
 :name "jekyll-serve"
 :buffer "jekyll-serve"
 :command '("bundle" "exec" "jekyll" "serve")
 :delete-exited-processes t
 :filter (lambda (process text)
           (if (string-match ".*done in [0-9.]+ seconds.*" text)
               (message "%s" (propertize "Blog serve: running" 'face '(:foreground "blue"))))
           (internal-default-process-filter process text))
 :sentinel (lambda (process state)
             (cond
              ((and (eq (process-status process) 'exit)
                    (zerop (process-exit-status process)))
               (message "%s" (propertize "Blog serve: stopped" 'face '(:foreground "blue"))))
              ((eq (process-status process) 'run)
               (accept-process-output process))
              (t (error (concat "Jekyll Serve: " state))))))
#+end_src

For convenience, I want the one function to start and stop the local
server. The logic to achieve this is simple:
- If =jekyll-serve= process exists, then kill it.
- If process doesn't exist¬†‚Äî start the server.

#+begin_src emacs-lisp
(defun org-jekyll--suffix-serve-toggle ()
  "Serve blog or stop serving the blog."
  (interactive)
  (let ((current-path (file-name-directory buffer-file-name)))
    (if (eq (process-status "jekyll-serve") ' run)
        (interrupt-process "jekyll-serve")
      (cd (expand-file-name org-jekyll-paths-base-path))
      (make-process ...)
      (cd current-path))))
#+end_src

** Jekyll's working directory cleanup
:PROPERTIES:
:CUSTOM_ID: jekyll-clean
:END:

Cleanup of the working directory is not so simple. For the =bundle exec jekyl
clean=, a new call to =make-process= is enough:

#+begin_src emacs-lisp
(make-process
 :name "jekyll-clean"
 :buffer "jekyll-clean"
 :command '("bundle" "exec" "jekyll" "clean")
 :delete-exited-processes t
 :sentinel (lambda (process state)
             (cond
              ((and (eq (process-status process) 'exit)
                    (zerop (process-exit-status process)))
               (message "%s" (propertize "Blog cleaned" 'face '(:foreground "blue"))))
              ((eq (process-status process) 'run)
               (accept-process-output process))
              (t (error (concat "Jekyll Clean: " state))))))
#+end_src

But we also need to clean up the OrgMode export artifacts before the
=make-process= call. The =_articles/=, =_static/= and =_post/= catalogs should also be
cleaned up. I did this using the next S-expression:

#+begin_src emacs-lisp
(mapc (lambda (x)
        (mapc (lambda (file)
                (delete-file file nil))
              (mapcan (lambda (directory)
                        (directory-files-recursively (concat org-jekyll-paths-base-path directory) (cdr x) nil nil nil))
                        (car x))))
      `((("/_posts/en" "/_posts/ru") . "\\.html$")
        (("/assets/static" "/_static") . ,(concat "\\.png\\|\\.jpg$\\|\\.jpeg$"
                                                  "\\|"
                                                  "\\.JPG$\\|\\.svg$\\|\\.webm$"
                                                  "\\|"
                                                  "\\.webp$\\|\\.html$\\|\\.tar.bz2$"
                                                  "\\|"
                                                  "\\.org$\\|\\.gif$\\|\\.gpx$"
                                                  "\\|"
                                                  "\\.uxf$"))
        (("/_articles") . "\\.org$")))
#+end_src

The code may look overly complicated at first glance, but all it does is
iterate through the specified directories and delete files that match with the
specified regular expression.

The first lambda function =(lambda (x) ...)= simply passes each element of the
main list (for example, the first element is: =(("/_posts/en" "/_posts/ru")
. "\\.html$")=) into the next S-expression:

#+begin_src emacs-lisp
(mapc (lambda (file)
        (delete-file file nil))
      (mapcan (lambda (directory)
                (directory-files-recursively (concat org-jekyll-paths-base-path directory) (cdr x) nil nil nil))
              (car x)))
#+end_src

This is where things get complicated. The second =mapc= parameter is not just an
=x= variable with a list element inside, but one another S-expression. This
expression is evaluated first, and it's result (one another list of files) is
processed with a lambda function that simply deletes the file:

#+begin_src emacs-lisp
(lambda (file)
  (delete-file file nil))
#+end_src

=mapcan=[fn:mapcan] S-expression does the following:
1. Takes the first element of the list containing paths/regexes with =(car
   x)=. Result will be one another list with paths to directories, for example:
   =("/_posts/en" "/_posts/ru")=.
2. Inside the lambda function, the =directory-files-recursively= function is
   used to get list of files in the catalog that match the regular
   expression. The regex is the last element of the =x= list and can be accessed
   via =(cdr x)=.
3. Result looks like this: =(("/_posts/en/article1/file.org"
   "/_posts/en/article2/file.org") ("/_posts/ru/article1/file.org"
   "/_posts/ru/article2/file.org"))=. If I were using =mapc=, then lambda
   function for file deletion will cause error¬†‚Äî because function will receive
   list instead of string.

   For example, the following code prints =file= variable contents in case of
   using =mapc=:
   #+begin_src emacs-lisp
   (mapc (lambda (file)
           (print file))
         (mapc (lambda (directory)
                 directory)
               '(("a" "b") ("c" "d"))))

   ("a" "b")
   ("c" "d")
   #+end_src
4. We need to flatten the list. And =mapcan= function can just do that. It can
   transfrom list from item #3 to: =("/_posts/en/article1/file.org"
   "/_posts/en/article2/file.org" "/_posts/ru/article1/file.org"
   "/_posts/ru/article2/file.org")=. And returns the result to the upper =mapc=.

   For example, there is the content of =file= variable inside lambda function
   when we use =mapcan=:
   
   #+begin_src emacs-lisp
   (mapc (lambda (file)
           (print file))
         (mapcan (lambda (directory)
                   directory)
                 '(("a" "b") ("c" "d"))))

   "a"
   "b"
   "c"
   "d"
   #+end_src

The resulting code of the function to clean up Jekyll's working directory:

#+begin_src emacs-lisp
(defun org-jekyll--suffix-clear ()
  "Clear blog files."
  (interactive)
  (let ((current-path (file-name-directory buffer-file-name)))
    (cd (expand-file-name org-jekyll-paths-base-path))
    (mapc (lambda (x)
            (mapc (lambda (file)
                    (delete-file file nil))
                  (mapcan (lambda (directory)
                            (directory-files-recursively (concat org-jekyll-paths-base-path directory) (cdr x) nil nil nil))
                          (car x))))
          `((("/_posts/en" "/_posts/ru") . "\\.html$")
            (("/assets/static" "/_static") . ,(concat "\\.png$\\|\\.jpg$\\|\\.jpeg$"
                                                      "\\|"
                                                      "\\.JPG$\\|\\.svg$\\|\\.webm$"
                                                      "\\|"
                                                      "\\.webp$\\|\\.html$\\|\\.tar.bz2$"
                                                      "\\|"
                                                      "\\.org$\\|\\.gif$\\|\\.gpx$"
                                                      "\\|"
                                                      "\\.svg$"))
            (("/_articles") . "\\.org$\\|\\.png$")))
    (make-process
     :name "jekyll-clean"
     :buffer "jekyll-clean"
     :command '("bundle" "exec" "jekyll" "clean")
     :delete-exited-processes t
     :sentinel (lambda (process state)
                 (cond
                  ((and (eq (process-status process) 'exit)
                        (zerop (process-exit-status process)))
                   (message "%s" (propertize "Blog cleaned" 'face '(:foreground "blue"))))
                  ((eq (process-status process) 'run)
                   (accept-process-output process))
                  (t (error (concat "Jekyll Clean: " state))))))))
#+end_src

** UI (transient)
:PROPERTIES:
:CUSTOM_ID: transient-ui
:END:

I wanted to add /a comfortable for Emacs users/ interface to all these set of
functions. Here I didn't reinvent the wheel and just used the [[https://jd.codes/posts/transient-emacs/][Transient]]
library as in [[https://mastodon.social/@fabrik42][Christian Dewein's]] code. The result looks like this:

#+CAPTION: UI of org-jekyll plugin
#+ATTR_HTML: :align center :alt Panel with blog actions
[[file:transient_panel.png]]

Some suffixes (functions that a called when the corresponding menu item is
selected) have already been described above. A prefix (code that describes the
panel) looks like this:

#+begin_src emacs-lisp
;; Transient keys description:

(transient-define-prefix org-jekyll-layout-descriptions ()
  "Transient layout with blog commands."
  [:description (lambda () (concat org-jekyll-url " control panel" "\n"))
                ["Development"
                 ("b" "Build blog" org-jekyll--suffix-build)
                 ("s" org-jekyll--suffix-serve-toggle
                  :description (lambda () (if (eq (process-status "jekyll-serve") 'run)
                                              "Stop serving local blog"
                                            "Serve local blog")))
                 ("o" "Open served blog" org-jekyll--suffix-open-blog)
                 ("O" "Open blog in Web" org-jekyll--suffix-open-remote-blog)
                 ("B" "Open build log" org-jekyll--suffix-open-build-log)
                 ("l" "Open serve log" org-jekyll--suffix-open-serve-log)
                 ("C" "Clear blog directory" org-jekyll--suffix-clear)]
                ["Actions"
                 ("n" "New blog post" org-jekyll--suffix-create-post)]])

;; Function to call main menu:

(defun org-jekyll-menu ()
  "Open blog control center."
  (interactive)
  (org-jekyll-layout-descriptions))
#+end_src

Functions-suffixes is just a usual functions without parameters, for example:

#+begin_src emacs-lisp
(defun org-jekyll--suffix-open-blog ()
  "Open locally served blog."
  (interactive)
  (browse-url "http://127.0.0.1:8000/"))

(defun org-jekyll--suffix-open-remote-blog ()
  "Open remote blog."
  (interactive)
  (browse-url org-jekyll-url))

(defun org-jekyll--suffix-create-post ()
  "Create new blog post."
  (interactive)
  (cd (expand-file-name org-jekyll-paths-base-path))
  (org-jekyll--create-new-post))
#+end_src

The start/stop local server menu item includes the code to check the status of
the local server via the check for process ="jekyll-serve"= status.

This panel can be displayed via the =org-jekyll-menu= function. Going a bit
further¬†‚Äî this function is called by a hotkey in my plugin.

** Emacs plugin specific code
:PROPERTIES:
:CUSTOM_ID: emacs-plugin
:END:

The only thing left to do is to make an Emacs plugin out of my code. I'm not
going to call =eval-buffer= every time, am I? Let Emacs itself load all the
necessary code at startup.

First, I checked the source code with =M-x checkdoc= and added missing
comments. Then, I added the necessary dependencies to the header:

#+begin_src emacs-lisp
(require 'htmlize)
(require 'ox-publish)
(require 'transient)
#+end_src

=htmlize= is needed to color source code blocks in the resulting HTML,
=ox-publish= is an extension to OrgMode for publishing files. Why the =transient=
library is necessary, I've already described above.

I've also added necessary =provide= to the end of the file:

#+begin_src emacs-lisp
(provide 'org-jekyll)
#+end_src

And I described the minor mode, which calls up the transient menu via the =C-c
b= hotkey:

#+begin_src emacs-lisp
;; Minor mode:

;;;###autoload
(define-minor-mode org-jekyll-mode
  "Enable transient menu to operate with blog-related OrgMode files."
  :lighter " oj"
  :global nil
  :init-value nil
  :keymap (list (cons (kbd "C-c b") #'org-jekyll-menu)))
#+end_src

Now, if minor mode is enabled with =M-x org-jekyll-mode=, then the build can be
started with =C-c b b= hotkey, new post can be created with =C-c b n= and so
on. The transient menu described above can be accessed with =C-c b=.

** Loading plugin in Emacs
:PROPERTIES:
:CUSTOM_ID: loading-plugin-in-emacs
:END:

The last thing left¬†‚Äî is to properly load this plugin into Emacs. The new
minor mode should only be enabled when I open a blogpost file, and shouldn't
interfere with other org files.

This can be achieved with the next function:

#+begin_src emacs-lisp
;;;###autoload
(defun org-jekyll-init ()
  (if (and buffer-file-name
           (string-match "^/.+/article-[[:lower:]]\\{2\\}\\.org" (buffer-file-name)))
      (org-jekyll-mode 1)))
#+end_src

And with the next =use-package= configuration:

#+begin_src emacs-lisp
(use-package org-jekyll
  :load-path "~/rsync/blog/"
  :ensure nil
  :commands org-jekyll-init
  :hook (org-mode . org-jekyll-init))
#+end_src

Now every time I open an org file, my =org-jekyll-init= is called. When I opened
the blog post, =org-jekyll-mode= was enabled and custom hotkeys plus transient
menu became accessible.

* Source code
:PROPERTIES:
:CUSTOM_ID: source-code
:END:

I didn't intend this plugin to be usable by others¬†‚Äî after all, it has my
article directory structure and my file naming conventions hardcoded into
it. That's why I didn't publish it in MELPA or set up a separate repository
for it.

The source code is in the same repository as the files for my blog. You can
look at it [[https://github.com/eugeneandrienko/eugeneandrienko.github.io/blob/master/org-jekyll.el][at this link]].

As a result, if I need to switch to another static site generator, it will be
enough to tweak the functions involved in the export from OrgMode to make the
generated HTML fit the new engine. My article sources and the entire directory
structure for them will remain untouched.

* What else could be improved?
:PROPERTIES:
:CUSTOM_ID: plugin-improvement
:END:

There are a few things in the current version of the plugin that are
definitely worth improving:
1. =org-publish-project= call should be asynchronous¬†‚Äî so it will not block
   Emacs interface during evaluation, like now. =Org-publish-project= and
   =make-process= calls should be sequental, instead Jekyll will try to build
   the blog while files for it not ready yet.
2. =org-publish-project= could operate with Org Babel block. I want to use these
   blocks to describe different complicated schemes as code for [[https://github.com/plantuml/plantuml][PlantUML]] right
   in blogpost text. After =org-publish-project= call there are ready images
   inside the =_articles/= catalog (see to [[https://hostsharing.coop/@dzu][@dsu]] blogpost with details:
   https://blog.lazy-evaluation.net/posts/orgmode-diagrams.html).

   Needs to modify ~org-jekyll--prepare-static~ to copy necessary files from the
   new place. And ~org-jekyll--suffix-clear~ function should delete these files.

   /Already realised¬†‚Äî look to the commit
   [[https://github.com/eugeneandrienko/eugeneandrienko.github.io/commit/e919bd6d2b7f3a0b853fdf71f288f5c9f1749575][e919bd6d2b7f3a0b853fdf71f288f5c9f1749575]]./

* Notes
:PROPERTIES:
:CUSTOM_ID: notes
:END:

[fn:virtue_signaling] First, in mid-March 2022, Visa and Master Card cut me
off from just about everything what I could buy outside the country with fiat
money. Because of which I could neither transfer my domain to another
registrar nor pay for my VPS in Finland.

[fn:namecheap] That's a separate and utterly "beautiful" story. On 28th
February 2022 NameCheap sent me a notification letter that they will
undelegate my domain in 7 days because I am from the "wrong" country (this was
long before the ban on providing IT services to companies on the sanctions
list, to which I am in no way related¬†‚Äî most likely the "happy letters" were
sent because of the registration/billing address for the sake of the
above-mentioned virtue signaling. They didn't even check the real citizenship
of they customers!):

#+ATTR_HTML: :align center :alt Namecheap services discontinuation
[[file:namecheap1.png]]

In the next two letters they extended the deadline by two weeks. And offered
me to either leave the country before the deadline, or +get involved in protest
activities+ go to jail for a dozen years if I wanted to continue using their
servicesü§°. I'm assuming these letters were composed by some not-so-smart
person from a first-world country whose only encounter with the repressive
apparatus of state was not being sold alcohol without an ID at a Wallmart
checkout; and who knows about life outside his well-established democracy
institutions from the Hunger Games movies. And who is sure that emigrating is
easy¬†‚Äî you fill out some paperwork at customs upon entry, and wham¬†‚Äî you're
already a citizen of of another country.

#+ATTR_HTML: :align center :alt Namecheap next emails about service shutdown
[[file:namecheap2.png]]

I didn't have time to transfer my domain to another registrar at that time,
because my cards were quickly and suddenly disconnected from Visa/MasterCard¬†‚Äî
and I couldn't pay another domain name registrar for the transfer. After a
*year (!)* it turned out that my domain was still being serviced by NameCheap¬†‚Äî
after I received an email from them reminding me to drop off some of my
"dirty" money to renew the domainü§°ü§°:

#+ATTR_HTML: :align center :alt Namecheap domain renewal
[[file:namecheap3.png]]

Of course, the services of NameCheap since then I no longer use and bypass it
tenth road, having made a choice in favor of a more sane domain registrar,
located as far away as possible (on the other side of the planet) from
me. Moral of the story¬†‚Äî don't trust corporations and all sorts of centralized
and closed services that you don't control. They will throw you out without a
second thought if it is to their advantage. You should always have a backup
plan in case something goes wrong.

[fn:jekyll] It looks like simple enough and at the same time it proved to be
quite popular and was (and still is) often used by different hosting providers
as a pre-installed application.

[fn:javascript] I don't like JS, plus without it the blog is unimaginably fast
to open on my Thinkpad X220.

[fn:org-publish-project] https://orgmode.org/worg/org-tutorials/org-publish-html-tutorial.html

[fn:clojure] During my university days I was a bit interested in Lisp, read
"Structure and Interpretation of Computer Programs" and wrote various simple
programs in Clojure. The source code of some of them is still exists in
GitHub:
- https://github.com/eugeneandrienko/jamendo-client
- https://github.com/eugeneandrienko/cs-alias-clj

[fn:defcustom] https://www.gnu.org/software/emacs/manual/html_node/eintr/defcustom.html

[fn:quoting] See
https://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html and
https://www.gnu.org/software/emacs/manual/html_node/elisp/Backquote.html

[fn:directory-files-recursively] https://www.gnu.org/software/emacs/manual/html_node/elisp/Contents-of-Directories.html#index-directory_002dfiles_002drecursively

[fn:seq-filter] https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequence-Functions.html#index-seq_002dfilter

[fn:mapc] https://www.gnu.org/software/emacs/manual/html_node/elisp/Mapping-Functions.html#index-mapc

[fn:lang_code] A separate directory for each language is necessary for the
plugin [[https://github.com/untra/polyglot][jekyll-polyglot]], which provides a JavaScript-free way to publish the
same article in different languages.

[fn:regex-search] https://www.gnu.org/software/emacs/manual/html_node/elisp/Regexp-Search.html

[fn:let-star] https://www.gnu.org/software/emacs/manual/html_node/elisp/Local-Variables.html#index-let_002a

[fn:toc-org] My settings for the toc-org plugin, with which it starts to
understand the =:TOC_2_blog:= tag and generates section links, properly handled
when exported to HTML:

#+begin_src emacs-lisp
(use-package toc-org
  :pin melpa
  :hook (org-mode . toc-org-mode)
  :config
  (defun toc-org-hrefify-blog (str &optional hash)
    (concat "* " (toc-org-format-visible-link str))))
#+end_src

[fn:plist-get] https://www.gnu.org/software/emacs/manual/html_node/elisp/Plist-Access.html#index-plist_002dget

[fn:make-process] https://www.gnu.org/software/emacs/manual/html_node/elisp/Asynchronous-Processes.html#index-make_002dprocess

[fn:message] https://www.gnu.org/software/emacs/manual/html_node/elisp/Displaying-Messages.html#index-message

[fn:propertize] https://www.gnu.org/software/emacs/manual/html_node/elisp/Changing-Properties.html#index-propertize

[fn:mapcan] https://www.gnu.org/software/emacs/manual/html_node/elisp/Mapping-Functions.html#index-mapcan
