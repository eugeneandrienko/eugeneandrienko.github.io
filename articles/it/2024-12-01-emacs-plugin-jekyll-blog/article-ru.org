#+BEGIN_EXPORT html
---
layout: post
title: Как я сделал Emacs-плагин для сборки своего блога
category: it
date: 2024-12-01
lang: ru
comments: false
hidden:
  - related_posts
image: /assets/static/emacs-plugin-jekyll-blog-header.png
banner:
  image: /assets/static/emacs-plugin-jekyll-blog-header.png
  opacity: 0.6
summary: Emacs Lisp программа, упрощающая сборку Jekyll-блога из org-файлов
tags: emacs
---
#+END_EXPORT

* TOC                                                            :TOC_2_blog:
- [[* Введение][Введение]]
- [[* Первая версия генератора блога][Первая версия генератора блога]]
- [[* Генерация Jekyll-блога c помощью Emacs Lisp][Генерация Jekyll-блога c помощью Emacs Lisp]]
  - [[* Преобразование org-файлов в HTML][Преобразование org-файлов в HTML]]
  - [[* Копирование файлов в промежуточный каталог][Копирование файлов в промежуточный каталог]]
  - [[* Редактирование HTML файлов][Редактирование HTML файлов]]
  - [[* Экспорт статических файлов][Экспорт статических файлов]]
  - [[* Вызов Jekyll из Emacs][Вызов Jekyll из Emacs]]
  - [[* Создание нового поста][Создание нового поста]]
  - [[* Запуск локального сервера Jekyll][Запуск локального сервера Jekyll]]
  - [[* Очистка рабочего каталога Jekyll][Очистка рабочего каталога Jekyll]]
  - [[* Интерфейс пользователя (transient)][Интерфейс пользователя (transient)]]
  - [[* Оформление в виде плагина][Оформление в виде плагина]]
  - [[* Загрузка плагина в Emacs][Загрузка плагина в Emacs]]
- [[* Исходный код плагина][Исходный код плагина]]
- [[* Что ещё можно улучшить?][Что ещё можно улучшить?]]
- [[* Примечания][Примечания]]

* Введение
:PROPERTIES:
:CUSTOM_ID: preface
:END:

В этом посте я рассказываю о том как написал свой небольшой Emacs-плагин
упрощающий работу с блогом на статическом движке. С этим плагином возможно
писать и публиковать посты для блога в OrgMode несмотря на то, что практически
все распространённые генераторы статических сайтов поддерживают в основном
языки разметки Markdown, reStructuredText или HTML🌚.

В плане блоггинга я успел перепробовать много всего:
- Писал в LiveJournal
- Сэлфхостил блог на Wordpress с «традиционным» LAMP-стэком
- Вёл блог на Blogger.com
- Снова сэлфхостил свой блог, собираемый при помощи генератора статических
  сайтов Pelican, с добавлением комментариев на Disqus
- Пробовал [[https://hackage.haskell.org/package/pencil][pencil]]
- и так далее...

В конечном итоге, необходимость администрирования и обновления Apache/Nginx,
MySQL/PostgreSQL, php-fpm и т.д. и т.п. — изрядно мне надоела. Как и всякие
куцые WYSIWYG-редакторы и ненужные «обновления» блоггинг-платформ. Тут же как
раз подоспел всякий «virtue signaling», из-за которого я
лишился[fn:virtue_signaling] своего VPS (он обеспечивал мне доступ в «большой
интернет» — раньше, в 90-х и нулевых была такая глобальная сеть, при помощи
которой можно было свободно общаться с людьми по всему миру и без границ,
блокировок по GeoIP и DPI). А также почти лишился доменного
имени[fn:namecheap].

Примерно в этот момент я пришёл к использованию [[https://jekyllrb.com/][Jekyll]][fn:jekyll] в качестве
статического генератора для своего блога. Его копия, со всеми HTML и CSS
файлами, хранится у меня на машине и не зависит от сторонних CDN, библиотек и
всего прочего, к чему я могу потерять доступ в любой момент. Пришлось
«немного» подправить тему [[https://github.com/jeffreytse/jekyll-theme-yat][Yat]], чтобы там не было ни JS[fn:javascript], ни
подгрузки ресурсов со сторонних CDN. При локальном использовании, единственная
оставшаяся зависимость — от самого Jekyll и от его плагинов. Но они и так уже
лежат на жёстком диске и работают без подключения к Интернету — а с жёсткого
диска они никуда не пропадут (если помнить о бэкапах).

Тогда же я задумался о том, как бы организовать свои статьи для блога так,
чтобы:
1. Тексты постов были не сильно привязаны к генератору статических сайтов и я
   мог без особой боли сменить один генератор на другой, если разработчики
   Jekyll вдруг решат дискриминировать людей по гражданству или по месту
   жительства ([[https://en.wikipedia.org/wiki/Discrimination_based_on_nationality][discrimination based on nationality]]).
2. Блог как можно меньше зависел от чужой инфраструктуры. Единственная
   зависимость, от которой я пока что не могу уйти — это зависимость от
   регистратора доменных имён (остаётся только избегать регистраторов,
   замеченных в дискриминации, а также тех, что работают в моей местной
   юрисдикции). В качестве хостинга для статического сайта подойдёт же любая
   микроволновка в правильном месте — в таком, где не занимаются разрушением
   связности глобальной сети.
3. Можно было редактировать посты удобным мне методом — т.е. в Emacs, при
   помощи Org Mode. А не с Markdown или же вообще в WYSIWYG веб-редакторе.
4. Я мог сам выбрать для себя структуру каталогов с исходниками статей, а не
   пользоваться той, что навязана разработчиками генератора статических
   сайтов.

Если п. 2 нельзя решить, написав немного кода на Emacs Lisp, то остальные
проблемы вполне себе решаемы подобным образом.

* Первая версия генератора блога
:PROPERTIES:
:CUSTOM_ID: generator-first-version
:END:

Достаточно быстро я сделал первую версию конвертера OrgMode⇒Jekyll на основе
bash, sed, pandoc и самописного Java-фильтра для pandoc — и использовал её
почти год.

Все посты, которые обрабатывал этот конвертер, были размещены в каталоге
=articles/=, каждый в своём подкаталоге:

#+begin_example
rsync/blog (master) % tree --noreport articles
articles/
├── arms/
├── cycling/
│   ├── 2020-05-17-thanks-for-living/
│   │   ├── article-ru.org
│   │   ├── hate of car drivers.jpg
│   │   ├── kamennoostrovskii.jpg
│   │   ├── trollface.jpg
│   │   ├── truck.gif
│   │   └── ushakovski most.jpg
│   ├── 2021-04-08-vk-cyclist-types/
│   │   ├── article-ru.org
│   │   ├── hate of car drivers.jpg
│   │   ├── usual-seat-as-urbanist-thinks.jpg
│   │   └── usual-seat.jpg
├── it/
│   ├── 2020-09-09-thinkpad-x220-freebsd/
│   │   ├── article-en.org
│   │   ├── article-ru.org
│   │   └── freebsd_intel_glitches.jpg
│   ├── 2023-12-20-plain-text-accounting/
│   ├── 2024-01-02-life-in-console/
│   ├── 2024-07-07-thinkpad-x220-second-life/
│   ├── 2024-10-27-freebsd-bhyve-windows/
│   ├── 2024-11-09-emacs-plugin-jekyll-blog/
│   ├── draft-palm-tung-e2-archaeological/
│   │   ├── 20231223_141710.jpg
│   │   ├── 20231223_142550.jpg
│   │   ├── 20231230_200500.jpg
│   │   ├── 20231231_144949.jpg
│   │   ├── 20231231_205901.jpg
│   │   ├── 20240101_162620.jpg
│   │   ├── 20240101_215815.jpg
│   │   ├── 20240101_215908.jpg
│   │   ├── article-ru.org
├── leatherwork/
│   └── 2021-01-29-leatherwork-useful-links/
│       └── article-ru.org
└── photo/
#+end_example

Эту древовидную структуру я использую до сих пор. Она позволяет иметь перед
глазами все, относящиеся к конкретному посту, файлы. К тому же, я могу открыть
org-файл с постом в Emacs и сразу же увижу его практически в том же виде, в
каком он попадёт в блог:

#+CAPTION: Черновик поста, открытый в Emacs
#+ATTR_HTML: :align center :alt Post's draft, opened in Emacs
[[file:emacs-blog-post.png]]

В каталоге с блогом я создал специальный =Makefile=, который запускал не менее
специальный bash-скрипт. Этот скрипт сканировал каталог =articles/= и помещал
найденные файлы с текстами постов в следующий конвейер:

#+BEGIN_SRC plantuml :exports none :file first_generator.png
@startuml
!theme sunlust
skinparam handwritten true
scale 2.2

title Org2HTML conveyor

() "OrgMode files" as OrgModeSrc
() "HTML files" as HtmlFiles
package "Makefile" {
  package "Shell script" {
    [sed] as sed1
    OrgModeSrc - sed1
    note right of sed1 : Fixes links to static files
    sed1 ..> [awk] : Patched OrgMode files
    note left of [awk] : Inserts language code to header
    [pandoc] as pandoc1
    [awk] ..> pandoc1 : Patched OrgMode files
    note right of pandoc1 : Translates OrgMode to AST
    pandoc1 ..> [Java filter] : AST
    note left of [Java filter]
      Inserts language code to
      proper place, inserts
      path to banner image
      and summary
    end note
    [pandoc] as pandoc2
    note right of pandoc2 : Translates AST to Markdown
    [Java filter] ..> pandoc2 : Patched AST
    [sed] as sed2
    note left of sed2 : Fixes titles in generated files
    pandoc2 ..> sed2 : Markdown files
  }
  sed2 ..> [bundle exec jekyll build] : Patched Markdown files
}
[bundle exec jekyll build] - HtmlFiles

footer //First and obsolete version, not in use!//
@enduml
#+END_SRC

#+CAPTION: Конвейер, превращающий org-файлы в HTML-файлы
#+ATTR_HTML: :align center :alt Conveyor for Org2HTML transformation
[[file:first_generator.png]]

Посмотреть на использовавшийся код можно вот [[https://github.com/eugeneandrienko/eugeneandrienko.github.io/blob/3b70ec4997a063fdd3c1bf4c23c3c9a5d78b78e3/README.org][в этом коммите]], в файле
=README.org=. Код для Java-фильтра для pandoc лежит [[https://github.com/eugeneandrienko/pandoc_jekyll][в отдельном репозитории]].

Очевидно, что всё это было переусложнено. Гораздо удобнее было бы, если бы
итоговый HTML-файл генерировался напрямую из OrgMode, без всяких
дополнительных преобразований. Тем более, что в OrgMode уже есть функции для
экспорта файлов в различные форматы.

И тут в Mastodon мне попалась на глаза статья [[https://mastodon.social/@fabrik42][Christian Dewein]]: [[https://christiandewein.com/publishing-with-jekyll-emacs-org-mode][Publishing on
the web with Jekyll, Emacs and Org-Mode]]...

* Генерация Jekyll-блога c помощью Emacs Lisp
:PROPERTIES:
:CUSTOM_ID: emacs-lisp-jekyll-gen
:END:

Как оказалось, весь мой конвейер из =sed= + =awk= + =pandoc= + =Java-фильтр= можно
спокойно выкинуть и заменить на вызов функции
=org-publish-project=[fn:org-publish-project]. Org Mode сам может экспортировать
org-файлы в HTML-файлы, сразу готовые для использования в Jekyll, без
дополнительной конвертации Markdown⇒HTML.

У меня уже был некоторый опыт программирования на Lisp, а точнее на
Clojure[fn:clojure], поэтому я спокойно взялся писать свой плагин, по мотивам
кода от [[https://mastodon.social/@fabrik42][Christian Dewein]]. Программировать на Emacs Lisp в Emacs одно
удовольствие — тут тебе и встроенная справка по языку через =C-h f=, =C-h v= и так
далее. И встроенный REPL (=M-x ielm=). И встроенный отладчик. Можно спокойно
играться с [[https://www.s-expressions.org/home][S-expressions]], сразу же проверяя как исполняются куски кода в REPL
и строить программу «по кирпичикам».

** Преобразование org-файлов в HTML
:PROPERTIES:
:CUSTOM_ID: convert-org2html
:END:

Вышеупомянутая функция =org-publish-project= умеет брать файлы из одного
каталога, конвертировать их в нужный формат и сохранять в другой каталог. Что,
куда и как экспортировать настраивается внутри специального списка с именем
=org-publish-project-alist=, каждый элемент которого — отдельный параметр для
тонкой настройки процесса экспорта.

Код, который умеет брать org-файлы каталога =~/test=, перегонять их в HTML для
Jekyll и сохранять в =~/results=, будет выглядеть примерно вот так:

#+begin_src emacs-lisp
(let ((org-publish-project-alist `(("org-jekyll-org"
                                    :base-directory "~/test"
                                    :base-extension "org"
                                    :publishing-directory "~/results"
                                    :publishing-function org-html-publish-to-html
                                    :html-extension "html"
                                    :headline-levels 5
                                    :html-toplevel-hlevel 2
                                    :html-html5-fancy t
                                    :html-table-attributes (:border "2" :cellspacing "0" :cellpadding "6" :frame "void")
                                    :section-numbers nil
                                    :html-inline-images t
                                    :htmlized-source t
                                    :with-toc nil
                                    :with-sub-superscript nil
                                    :body-only t
                                    :recursive t))))
  (org-publish-project "org-jekyll-org" t nil))
#+end_src

Из важных параметров здесь есть:
- =:base-directory= — путь к каталогу, откуда будут браться файлы для экспорта.
- =:base-extension= — какие расширения должны быть у файлов для экспорта.
- ~:publishing-directory~ — путь к каталогу, куда будут помещаться HTML-файлы
  после экспорта.

Остальные параметры содержат разные тонкие настройки для конвертации в HTML, с
которыми мои посты в блоге выглядят так, как я хочу.

Неплохо бы иметь возможность настраивать имена каталогов, чтобы не копаться
каждый раз в исходном коде, меняя строковые константы. Для этого в Emacs Lisp
есть функция =defcustom=[fn:defcustom]. Она позволяет описать настройки для
плагина так, чтобы их можно было менять общепринятыми способами — через =M-x
customize= или через секцию =:custom= в =use-package=:

#+CAPTION: Интерфейс M-x customize
#+ATTR_HTML: :align center :alt Emacs M-x customize
[[file:customize.png]]

Пути к нужным каталогам я описал через =defcustom= следующим образом:

#+begin_src emacs-lisp
(defgroup org-jekyll ()
  "Emacs mode to write on OrgMode for Jekyll blog."
  :group 'local
  :prefix "org-jekyll-"
  :link '(url-link :tag "Source code" "https://github.com/eugeneandrienko/eugeneandrienko.github.io"))

(defgroup org-jekyll-paths nil
  "Paths for emacs mode to write on OrgMode for Jekyll blog."
  :group 'org-jekyll
  :prefix "org-jekyll-paths-")

(defcustom org-jekyll-paths-base-path
  "~/rsync/blog"
  "Path to the base directory of my blog."
  :type 'directory
  :group 'org-jekyll-paths)

(defcustom org-jekyll-paths-articles-path
  (concat org-jekyll-paths-base-path "/articles")
  "Path to directory with original articles in Org format."
  :type 'directory
  :group 'org-jekyll-paths)
#+end_src

Здесь, первая S-expression описывает новый пункт меню в настройках Emacs,
вторая создаёт внутри него подпункт, внутри которого будет две настройки — с
путём к каталогу со всеми файлами для блога и с путём к каталогу со статьями.

В итоге, параметры в вышеприведённом вызове =org-publish-project= можно
переделать вот так:

#+begin_src emacs-lisp
(let ((org-publish-project-alist `(("org-jekyll-org"
                                    :base-directory ,org-jekyll-paths-articles-path
                                    :base-extension "org"
                                    :publishing-directory ,(concat org-jekyll-paths-base-path "/_posts")
                                    :publishing-function org-html-publish-to-html
#+end_src

Здесь, прямо внутри определения списка с настройками есть исполняемый код,
который формирует пути к нужным каталогам. Чтобы всё это работало — приходится
описывать список немного иначе, чем через привычную нотацию ='(1 2 3)=.

С одной стороны нам не нужно, чтобы все S-expressions внутри этого списка
исполнялись — ведь ="org-jekyll-org"= не имя функции, а имя OrgMode проекта для
публикации. Для этого можно было бы использовать привычный синтаксис вида
='("a" "b" "c")=.

#+begin_example
> ("a" "b" "c")
,*** Eval error ***  Invalid function: "a"
> '("a" "b" "c")
("a" "b" "c")
#+end_example

Но с другой стороны нам нужно, чтобы отдельные S-expressions — тот же =concat= —
всё же исполнялись. В нижеприведённом примере видно, что этого не происходит —
конструкция =(concat "b" "2")= воспринимается просто как отдельный элемент
списка и вместо неё не подставляется строка ="b2"=:

#+begin_example
> '("a" (concat "b" "2") "c")

("a"
 (concat "b" "2")
 "c")
#+end_example

Чтобы определить список, в котором отдельные элементы являются исполняемым
кодом, нужно использовать обратную кавычку, вместо
обычной[fn:quoting]. Элементы, которые будут исполняемыми S-expressions,
отмечаются при помощи запятой:

#+begin_example
> `("a" ,(concat "b" "2") "c")
("a" "b2" "c")
#+end_example

В идеальном случае вышеприведённого вызова =org-publish-project= достаточно для
превращения org-файлов в HTML. Но мой случай не идеальный — у меня org-файлы
не лежат все скопом в одном каталоге, а каждый в своём отдельном
подкаталоге!

Значит, перед вызовом =org-publish-project= нужно вызывать свою самописную
функцию, которая скопирует org-файлы с постами в промежуточный каталог, откуда
их и возьмёт =org-publish-project=. Для вызова пользовательской функции перед
началом публикации есть параметр =:preparation-function=, с которым наш код
начинает выглядеть вот так:

#+begin_src emacs-lisp
(let ((org-publish-project-alist `(("org-jekyll-org"
                                    :base-directory ,(concat org-jekyll-paths-base-path "/_articles")
                                    :base-extension "org"
                                    :publishing-directory ,(concat org-jekyll-paths-base-path "/_posts")
                                    :preparation-function org-jekyll--prepare-articles
#+end_src

Как видно, тут в качестве каталога с org-файлами для =org-publish-project= уже
указан промежуточный каталог =_articles/=.

** Копирование файлов в промежуточный каталог
:PROPERTIES:
:CUSTOM_ID: copy-2-tmp-catalog
:END:

Сначала нужно получить список org-файлов с постами, которые есть в каталоге
=articles/=. Его нам может вернуть функция
=directory-files-recursively=[fn:directory-files-recursively], если ей передать
путь к каталогу и регулярку, которой будут выбираться только org-файлы:

#+begin_src emacs-lisp
(directory-files-recursively org-jekyll-paths-articles-path "\\.org$" nil nil nil)

("~/rsync/blog/articles/cycling/2020-05-17-thanks-for-living/article-ru.org"
 "~/rsync/blog/articles/cycling/2021-04-08-vk-cyclist-types/article-ru.org"
 "~/rsync/blog/articles/cycling/2021-04-12-balticstar-north-open-2021/article-ru.org"
 "~/rsync/blog/articles/cycling/2021-05-17-insled-open/article-ru.org"
 "~/rsync/blog/articles/cycling/draft-osmand-howto/article-ru.org"
 "~/rsync/blog/articles/cycling/draft-qmapshack-howto/article-ru.org"
 ...
 "~/rsync/blog/articles/_post_template.org")
#+end_src

Как видно, в результате есть и черновики, которые не нужно экспортировать в
HTML, и файл с шаблоном для новых постов. Эти лишние файлы можно отфильтровать
при помощи =seq-filter=[fn:seq-filter] — он умеет убирать из списка (передаётся
вторым параметром) элементы не проходящие проверку в предикате из первого
параметра:

#+begin_src emacs-lisp
(seq-filter (lambda (path)
              (and
               (not (string-match org-jekyll-exclude-regex path))
               (not (string-match "\\(draft-\\)\\|\\(hidden-\\)" path))))
            (directory-files-recursively org-jekyll-paths-articles-path "\\.org$" nil nil nil))
#+end_src

Предикат — обычная лямбда-функция, которая проверяет, что путь из списка не
является путём к файлу с шаблоном =_post_template.org= и не содержит в себе
каталогов, начинающихся с =draft= или =hidden=.

Здесь =org-jekyll-exclude-regex= — ещё одна переменная, с регулярным выражением,
по которому будут отбрасываться неподходящие пути к org-файлам:

#+begin_src emacs-lisp
(defcustom org-jekyll-exclude-regex
  "\\(_post_template\\.org\\)\\|\\(\\.project\\)"
  "Regex to exclude unwanted files."
  :type 'regexp
  :group 'org-jekyll)
#+end_src

Теперь, когда у нас есть /правильный/ список путей к файлам, надо каждый его
элемент передать в функцию для копирования файлов. Это делается при помощи
=mapc=[fn:mapc], которая применяет лямбда-функцию из первого параметра к каждому
элементу списка, переданному вторым параметром:

#+begin_src emacs-lisp
(mapc (lambda (article)
        (
         ;; copy file in `article' path here
         )
        (seq-filter (lambda (path)
              (and
               (not (string-match org-jekyll-exclude-regex path))
               (not (string-match "\\(draft-\\)\\|\\(hidden-\\)" path))))
                    (directory-files-recursively org-jekyll-paths-articles-path "\\.org$" nil nil nil))
#+end_src

Элементы пути из переменной =article=: дата, URL и код языка[fn:lang_code] — я
использую, для того чтобы получить уникальное имя файла для промежуточного
каталога. Чтобы вытащить всё что надо из исходного пути к файлу — есть
регулярки с capturing groups. В Emacs для этого можно использовать функции
=string-match= и =match-string=[fn:regex-search]:

#+begin_src emacs-lisp
(string-match
 (concat org-jekyll-paths-articles-path
         "/\\(\\w+\\)/\\([0-9-]+\\)-\\([[:alnum:]-]+\\)/article-\\([[:lower:]]\\{2\\}\\)\\.org$")
 "~/rsync/blog/articles/photo/2024-09-01-summer-photos-2024/article-en.org")
0 (#o0, #x0, ?\C-@)

(match-string 1 "~/rsync/blog/articles/photo/2024-09-01-summer-photos-2024/article-en.org")
"photo"

(match-string 2 "~/rsync/blog/articles/photo/2024-09-01-summer-photos-2024/article-en.org")
"2024-09-01"

(match-string 3 "~/rsync/blog/articles/photo/2024-09-01-summer-photos-2024/article-en.org")
"summer-photos-2024"

(match-string 4 "~/rsync/blog/articles/photo/2024-09-01-summer-photos-2024/article-en.org")
"en"
#+end_src

В коде лямбды я заворачиваю всё это в =let*=[fn:let-star], чтобы впоследствии
просто обращаться к соответствующим переменным:

#+begin_src emacs-lisp
(lambda (article)
          (progn
            (string-match
             (concat org-jekyll-paths-articles-path
                     "/\\(\\w+\\)/\\([0-9-]+\\)-\\([[:alnum:]-]+\\)/article-\\([[:lower:]]\\{2\\}\\)\\.org$")
             article)
            (let*
                ((article-category (match-string 1 article))
                 (article-date (match-string 2 article))
                 (article-slug (match-string 3 article))
                 (article-lang (match-string 4 article)))
              (
                                        ;copy-file-here
               )))
#+end_src

Для удобства, добавим сюда ещё пару переменных:
1. Переменную с именем промежуточного каталога: путь к =_articles/= +
   =article-lang=. Путь к каталогу =_articles/= можно вытащить из настроек проекта
   ="org-jekyll-org"= — список с этими настройками передаётся в виде
   единственного параметра в функцию =org-jekyll--prepare-articles= и по имени
   параметра (=:base-directory=) можно получить нужное значение[fn:plist-get]:
   #+begin_src emacs-lisp
   (article-new-catalog (concat
                         (plist-get property-list ':base-directory)
                         "/"
                         article-lang))
   #+end_src
2. Переменную с уникальным путём к файлу со статьёй в промежуточном каталоге:
   #+begin_src emacs-lisp
   (article-processed (concat article-new-catalog "/" article-date "-" article-slug ".org"))
   #+end_src

В итоге, если к нам в переменной =article= пришёл путь
=~/rsync/blog/articles/photo/2024-09-01-summer-photos-2024/article-en.org=, то в
переменной =article-processed= будет новый путь:
=~/rsync/blog/_articles/en/2024-09-01-summer-photos-2024.org=.

Теперь, создание нового каталога (на всякий случай, если его нет) и
копирование файла делается вызовом пары функций в теле =let*=:

#+begin_src emacs-lisp
(make-directory article-new-catalog t)
(copy-file article article-processed t t t t)
#+end_src

Итоговая функция ~org-jekyll--prepare-articles~ выглядит так:

#+begin_src emacs-lisp
(defun org-jekyll--prepare-articles (property-list)
  "Copy articles to `_articles/' catalog before publishing. Rename
article file from `article-LANG.org' to
`YYYY-MM-DD-short-url.org'.

PROPERTY-LIST is a list of properties from
`org-publish-project-alist'."
  (mapc (lambda (article)
          (progn
            (string-match
             (concat org-jekyll-paths-articles-path
                     "/\\(\\w+\\)/\\([0-9-]+\\)-\\([[:alnum:]-]+\\)/article-\\([[:lower:]]\\{2\\}\\)\\.org$")
             article)
            (let*
                ((article-category (match-string 1 article))
                 (article-date (match-string 2 article))
                 (article-slug (match-string 3 article))
                 (article-lang (match-string 4 article))
                 (article-new-catalog (concat
                                       (plist-get property-list ':base-directory)
                                       "/"
                                       article-lang))
                 (article-processed (concat article-new-catalog "/" article-date "-" article-slug ".org")))
              (make-directory article-new-catalog t)
              (copy-file article article-processed t t t t))))
        (seq-filter (lambda (path)
                      (and
                       (not (string-match org-jekyll-exclude-regex path))
                       (not (string-match "\\(draft-\\)\\|\\(hidden-\\)" path))))
                    (directory-files-recursively org-jekyll-paths-articles-path "\\.org$" nil nil nil))))
#+end_src

Эта функция отлично работает в связке с ~org-publish-project~. Но есть один
нюанс — в итоговом HTML файле оказываются битые ссылки на картинки к
посту. Поскольку в исходном org-файле указаны пути к картинкам относительно
каталога с этим файлом — эти пути попадают в таком же виде в HTML.

Но в Jekyll такие статические файлы лежат по пути =/assets/static=. Решение тут
простое — после вызова =copy-file= поменять пути в скопированном временном
файле. Для этого я написал просто ещё одну функцию:

#+begin_src emacs-lisp
(defun org-jekyll--prepare-article (article)
  "Prepare article's text for Jekyll.

Modify OrgMode file before publish it. ARTICLE is a path to
OrgMode file with article. Files, stored in `_articles/' will be
modified, not original articles from `org-jekyll-paths-articles-path'
path.

ARTICLE is a path to intermediate org-file with article text"
  (with-temp-buffer
    (insert-file-contents article)
    (goto-char (point-min))
    (while (search-forward "[‎file:" nil t)
      (replace-match "[‏file://assets/static/" t t))
    (write-file article)))
#+end_src

Всё, что она делает — ищет в org-файле по пути из переменной =article= включения
статических файлов вида =[f‎ile:somefile.ext]= и меняет их на
=[f‎ile://assets/static/somefile.ext]=.

** Редактирование HTML файлов
:PROPERTIES:
:CUSTOM_ID: html-file-editing
:END:

К сожалению, =org-publish-project= вставляет в HTML-файл вещи, которые я там не
хочу видеть:
- Рандомно сгенерированные ID из HTML-тэгов
- Нумерацию изображений
- Тэг =:TOC_2_blog:= после заголовка «TOC». Этот тег нужен, чтобы расширение
  [[https://github.com/snosov1/toc-org/][toc-org]] автоматически генерировало[fn:toc-org] содержание для поста при
  каждом сохранении файла.
- Лишний заголовок для примечаний, причём не на языке поста.

Решение этой проблемы примерно такое же, как и в случае с правкой путей к
статическим файлам — нужна ещё одна функция, которая будет удалять всё лишнее
из HTML при помощи регулярок. В настройках =org-publish-project= можно указать
эту функцию в параметре =:completion-function=, чтобы она вызывалась после
экспорта в HTML.

Сама функция достаточно простая. Сначала получаем путь к каталогу с HTML
файлами из настроек =org-publish-project= и получаем список путей к этим файлам,
который передаётся в лямбду:

#+begin_src emacs-lisp
(defun org-jekyll--complete-articles (property-list)
  "Change published html-files via regular expressions.

Fix links to attached files. Remove \"Footnotes:\" section from
generated file. Remove autogenerated Org ids from html tags.

PROPERTY-LIST is a list of properties from
`org-publish-project-alist'."
  (let*
      ((publishing-directory (plist-get property-list ':publishing-directory)))
    (mapc (lambda (html)
            ; process `html' file
            )
          (directory-files-recursively publishing-directory "\\.html$" nil nil nil))))
#+end_src

Внутри лямбды есть ещё один вызов =mapc=, который работает со списком регулярок:

#+begin_src emacs-lisp
(mapc (lambda (x)
        (progn
          (goto-char (point-min))
          (while (re-search-forward (car x) nil t)
            (replace-match (cdr x) t nil))))
      '(("file://" . "/")
        ("<p><span class=\"figure-number\">[[:alnum:] :]+</span>\\(.+\\)</p>" . "<p style=\"text-align: center\"><i>\\1</i></p>")
        ("<h2 class=\"footnotes\">Footnotes: </h2>" . "")
        (" id=\"org[[:xdigit:]]\\{7\\}\"" . "")
        (" id=\"outline-container-org[[:xdigit:]]\\{7\\}\"" . "")
        (" id=\"text-org[[:xdigit:]]\\{7\\}\"" . "")
        ("<span class=\"TOC_2_blog\">TOC_2_blog</span>" . "")))
#+end_src

Здесь каждый элемент списка — ещё один список из двух элементов. Первый
элемент — регулярка, по которой ищется текст для замены. Второй элемент —
текст, на который надо заменить найденное. Обращения к этим элементам в коде
происходят при помощи =(car x)= и =(cdr x)= соответственно. Замена текста
производится стандартными для Emacs функциями для работы с регулярными
выражениями через временные буферы.

Итоговый код =org-jekyll--complete-articles= выглядит следующим образом:

#+begin_src emacs-lisp
(defun org-jekyll--complete-articles (property-list)
  "Change published html-files via regular expressions.

Fix links to attached files. Remove \"Footnotes:\" section from
generated file. Remove autogenerated Org ids from html tags.

PROPERTY-LIST is a list of properties from
`org-publish-project-alist'."
  (let*
      ((publishing-directory (plist-get property-list ':publishing-directory)))
    (mapc (lambda (html)
            (with-temp-buffer
              (insert-file-contents html)
              (mapc (lambda (x)
                      (progn
                        (goto-char (point-min))
                        (while (re-search-forward (car x) nil t)
                          (replace-match (cdr x) t nil))))
                    '(("file://" . "/")
                      ("<p><span class=\"figure-number\">[[:alnum:] :]+</span>\\(.+\\)</p>" . "<p style=\"text-align: center\"><i>\\1</i></p>")
                      ("<h2 class=\"footnotes\">Footnotes: </h2>" . "")
                      (" id=\"org[[:xdigit:]]\\{7\\}\"" . "")
                      (" id=\"outline-container-org[[:xdigit:]]\\{7\\}\"" . "")
                      (" id=\"text-org[[:xdigit:]]\\{7\\}\"" . "")
                      ("<span class=\"TOC_2_blog\">TOC_2_blog</span>" . "")))
              (write-file html)))
          (directory-files-recursively publishing-directory "\\.html$" nil nil nil))))
#+end_src

** Экспорт статических файлов
:PROPERTIES:
:CUSTOM_ID: static-files-export
:END:

Понятное дело, что одних лишь HTML-файлов для блога недостаточно. Нужны ещё
изображения и прочие файлы.

Их можно скопировать при помощи всё той же =org-publish-project=, причём
настройки для этого будут гораздо проще:

#+begin_src emacs-lisp
(let ((org-publish-project-alist `(("org-jekyll-static"
                                    :base-directory ,(concat org-jekyll-paths-base-path "/_static")
                                    :base-extension "jpg\\|JPG\\|jpeg\\|png\\|gif\\|webm\\|webp\\|gpx\\|tar.bz2\\|uxf"
                                    :publishing-directory ,(concat org-jekyll-paths-base-path "/assets/static")
                                    :publishing-function org-publish-attachment
                                    :preparation-function org-jekyll--prepare-static
                                    :exclude ,org-jekyll-exclude-regex
                                    :recursive t)))))
#+end_src

Здесь, в =:base-extension= указаны расширения для файлов, которые будут
экспортированы в каталог =:publishing-directory=.

Экспорт HTML файлов и копирование статических файлов можно объединить в одном
«проекте», чтобы выполнять все нужные действия с файлами за один вызов
функции:

#+begin_src emacs-lisp
(let ((org-publish-project-alist `(("org-jekyll-org"
                                    ...)
                                   ("org-jekyll-static"
                                    ...)
                                   ("org-jekyll" :components ("org-jekyll-org" "org-jekyll-static")))))
  (org-publish-project "org-jekyll" t nil))
#+end_src

Как видно из кода, при копировании статических файлов используется ещё одна
=:preparation-function= — =org-jekyll--prepare-static=. Она делает примерно то же,
что и =org-jekyll--prepare-articles= — копирует статические файлы из множества
подкаталогов с постами для блога в один временный каталог, откуда их сможет
взять =org-jekyll-project=. Работает эта функция примерно так же —
=directory-files-recursively= пробегается по каталогу =/articles= и копирует в
каталог =/_static= все файлы, кроме org-файлов с текстами статей:

#+begin_src emacs-lisp
(defun org-jekyll--prepare-static (property-list)
  "Copy static files to `/_static' directory.

PROPERTY-LIST is a list of properties from
`org-publish-project-alist'."
  (let
      ((static-directory (plist-get property-list `:base-directory)))
    (make-directory static-directory t)
    (mapc (lambda (filename)
            (progn
              (string-match (concat org-jekyll-paths-articles-path "/[[:alnum:]-/]+/\\([[:alnum:][:blank:]-_.]+\\)$") filename)
              (let
                  ((static-filename (match-string 1 filename)))
                (copy-file filename (concat static-directory "/" static-filename) t t t t))))
          (seq-filter (lambda (path)
                        (not (string-match
                              (concat org-jekyll-exclude-regex "\\|\\(article-[[:lower:]]+\\.org\\)")
                              path)))
                      (directory-files-recursively org-jekyll-paths-articles-path "." nil nil nil)))))
#+end_src

** Вызов Jekyll из Emacs
:PROPERTIES:
:CUSTOM_ID: jekyll-build-from-emacs
:END:

После того как у нас появились готовые HTML-файлы и все прочие статические
файлы, лежащие в /нужных/ местах — нужно вызвать Jekyll, чтобы он собрал мой
статический блог внутри каталога =_site/=. Для этого используется консольная
команда =bundle exec jekyll build=.

В статье [[https://mastodon.social/@fabrik42][Christian Dewein]] для вызова консольной команды используется плагин
[[https://github.com/rejeep/prodigy.el][Prodigy]]. Я счёл этот подход переусложнённым и просто запускаю отдельный
процесс при помощи функции =make-process=[fn:make-process]:

#+begin_src emacs-lisp
(make-process
 :name "jekyll-build"
 :buffer "jekyll-build"
 :command '("bundle" "exec" "jekyll" "build")
 :delete-exited-processes t
 :sentinel (lambda (process state)
             (cond
              ((and (eq (process-status process) 'exit)
                    (zerop (process-exit-status process)))
               (message "%s" (propertize "Blog built" 'face '(:foreground "blue"))))
              ((eq (process-status process) 'run)
               (accept-process-output process))
              (t (error (concat "Jekyll Build: " state))))))
#+end_src

Здесь, помимо банального вызова нужной команды внутри отдельного процесса,
обрабатывается её вывод через лямбду, которая либо выводит сообщение об
успехе, либо печатает ошибку.

Сообщения для пользователя печатаются в minibuffer при помощи функции
=message=[fn:message], текстом синего текста (настраивается при помощи
=propertize=[fn:propertize]):

#+ATTR_HTML: :align center :alt message function output
[[file:message.png]]

Вывод запущенного процесса отправляется в буфер =jekyll-build=, который
используется потом для просмотра лога сборки.

Экспорт файлов и запуск =bundle exec= объединяются в функции
=org-jekyll--suffix-build=, чтобы за один вызов превращать org-файлы в готовый
статический сайт:

#+begin_src emacs-lisp
(defun org-jekyll--suffix-build ()
  "Build the blog."
  (interactive)
  (cd (expand-file-name org-jekyll-paths-base-path))
  (let ((org-publish-project-alist `(("org-jekyll-org"
                                      ...)
                                     ("org-jekyll-static"
                                      ...)
                                     ("org-jekyll" :components ("org-jekyll-org" "org-jekyll-static"))))
        (current-path (file-name-directory buffer-file-name)))
    (cd (expand-file-name org-jekyll-paths-base-path))
    (org-publish-project "org-jekyll" t nil))
  (make-process
   :name "jekyll-build"
   :buffer "jekyll-build"
   :command '("bundle" "exec" "jekyll" "build")
   :delete-exited-processes t
   :sentinel (lambda (process state)
               ...))
  (cd current-path))
#+end_src

Поскольку при редактировании поста мы находимся в каталоге с постом, а сборка
блога будет работать только в каталоге из переменной
~org-jekyll-paths-base-path~ — мы сначала переходим в нужный каталог и только
потом начинаем сборку. После того как все нужные команды были вызваны —
возвращаемся в каталог с постом (сохранён в переменной =current-path=),
чтобы можно было спокойно продолжать работать с его файлами.

** Создание нового поста
:PROPERTIES:
:CUSTOM_ID: create-new-post
:END:

Добившись успешной сборки своего статического сайта, мне захотелось иметь
отдельную функцию, чтобы полуавтоматически создавать новый пост — не создавая
вручную новый подкаталог для него и не копируя каждый раз front matter для
Jekyll в org-файл. Будет удобно, если Emacs сам спросит у меня всё
необходимое, подготовит структуру файлов и каталогов, а затем сам откроет
буфер с уже готовым исходником нового поста.

Для получения ввода от пользователя в Emacs есть множество функций, но для
плагина достаточно четырёх самых простых:
- =read-string=: выводит вспомогательный текст в минибуфере и возвращает строку,
  введённую пользователем.
- =completing-read=: выводит меню в минибуфере и возвращает строку с выбранным
  пунктом меню. Элементы меню передаются вторым параметром. Третий параметр,
  если он не =nil=, включает режим строгого совпадения ввода пользователя с
  одним из пунктов меню.
- =y-or-n-p=: выводит текст в минибуфере и ждёт ответа «Да» или «Нет» от
  пользователя. Возвращает =t= или =nil=.
- =read-file-name=: выводит меню выбора файла в минибуфере и возвращает путь к
  выбранному файлу.

Достаточно быстро я набросал следующую конструкцию, которая спрашивает всё
необходимое и сохраняет результаты в отдельных переменных:

#+begin_src emacs-lisp
(let* ((category (completing-read "Enter category: "
                                  (seq-filter
                                   (lambda (category) (string-match "^[[:lower:]]+$" category))
                                   (directory-files org-jekyll-paths-articles-path nil
                                                    directory-files-no-dot-files-regexp
                                                    nil nil))
                                  nil t))
       (name (read-string "Enter title: "))
       (summary (read-string "Enter summary: "))
       (tags (read-string "Enter tags (space separated): "))
       (permalink (read-string "Enter permalink: "))
       (language (completing-read "Enter post language: " org-jekyll-languages nil t))
       (use-banner (y-or-n-p "Use banner?"))
       (banner (if use-banner
                   (read-file-name "Path to banner image: " nil nil t nil nil)
                 nil))))
#+end_src

#+CAPTION: UI создания нового поста
#+ATTR_HTML: :align center :alt new post creation UI
[[file:create_new_post.jpg]]

Внутри этого же =let*= сразу же вычисляются:
- Часть front matter для вставки заглавного изображения в блог:
  #+begin_src emacs-lisp
  (additional (concat (if use-banner
                          (concat "image: /assets/static/" (file-name-nondirectory banner) "\n"
                                  "banner:\n"
                                  "  image: /assets/static/" (file-name-nondirectory banner) "\n"
                                  "  opacity: 0.6\n")
                        "")
                      (concat "summary: " summary "\n")
                      (concat "tags: " tags)))
  #+end_src
- Путь к новому посту:
  #+begin_src emacs-lisp
  (dirname (concat path "/" category "/" date "-" permalink))
  #+end_src
- Имя файла с постом — к =article= добавляется введённый language code:
  #+begin_src emacs-lisp
  (filename (concat dirname "/" "article-" language ".org"))
  #+end_src

После вычисления всех переменных, в теле =let*= выполняется основная работа:
1. Создаётся подкаталог с ранее вычисленным именем:
   #+begin_src emacs-lisp
   (make-directory dirname t)
   #+end_src
2. Если для поста используется баннер, то в этот каталог копируется
   соответствующее изображение:
   #+begin_src emacs-lisp
   (if use-banner
       (copy-file banner (concat dirname "/" (file-name-nondirectory banner))))
   #+end_src
3. Берётся шаблон для поста по пути из переменной
   =org-jekyll-paths-template-path= и открывается во временном буфере для замены
   placeholder'ов реальными значениями. Потом этот буфер сохраняется как файл
   с именем из =filename=, по пути из =dirname=:
   {% raw %}
   #+begin_src emacs-lisp
   (with-temp-buffer
     (insert-file-contents template)
     (mapc
      (lambda (x) (progn
                    (goto-char (point-min))
                    (while (search-forward (car x) nil t)
                      (replace-match (cdr x) t t))))
      `(("{%NAME%}" . ,name)
        ("{%CATEGORY%}" . ,category)
        ("{%DATE%}" . ,date)
        ("{%LANG%}" . ,language)
        ("{%ADDITIONAL%}" . ,additional)))
     (write-file filename))
   #+end_src
   {% endraw %}
4. Сгенерированный файл открывается в текущем буфере с курсором в конце файла,
   чтобы сразу начать писать текст:
   #+begin_src emacs-lisp
   (with-current-buffer (find-file filename)
     (goto-char (point-max)))
   #+end_src

Шаблон поста, который я использую, лежит по пути из переменной
=org-jekyll-paths-template-path= (внутри функции он скопирован в локальную
переменную =template= для удобства):

#+begin_src emacs-lisp
(defcustom org-jekyll-paths-template-path
  (concat org-jekyll-paths-articles-path "/_post_template.org")
  "Path to post template."
  :type '(file :must-match t)
  :group 'org-jekyll-paths)
#+end_src

У меня эта переменная равна =~/rsync/blog/articles/_post_template.org=. Сам файл
выглядит вот так:

{% raw %}
#+begin_example
#+BEGIN_EXPORT html
---
layout: post
title: {%NAME%}
category: {%CATEGORY%}
date: {%DATE%}
lang: {%LANG%}
comments: false
hidden:
  - related_posts
{%ADDITIONAL%}
---
#+END_EXPORT


#+end_example
{% endraw %}

Как видно, тут просто описан jekyll-овский front matter и ничего больше.

** Запуск локального сервера Jekyll
:PROPERTIES:
:CUSTOM_ID: jekyll-local-server
:END:

Сборка блога и создание нового поста средствами Emacs Lisp готовы. Из часто
используемых действий у меня остался запуск локального сервера и очистка
рабочего каталога Jekyll от сгенерированных файлов.

С запуском сервера всё просто — надо лишь вызвать =make-process= с нужными
аргументами:

#+begin_src emacs-lisp
(make-process
 :name "jekyll-serve"
 :buffer "jekyll-serve"
 :command '("bundle" "exec" "jekyll" "serve")
 :delete-exited-processes t
 :filter (lambda (process text)
           (if (string-match ".*done in [0-9.]+ seconds.*" text)
               (message "%s" (propertize "Blog serve: running" 'face '(:foreground "blue"))))
           (internal-default-process-filter process text))
 :sentinel (lambda (process state)
             (cond
              ((and (eq (process-status process) 'exit)
                    (zerop (process-exit-status process)))
               (message "%s" (propertize "Blog serve: stopped" 'face '(:foreground "blue"))))
              ((eq (process-status process) 'run)
               (accept-process-output process))
              (t (error (concat "Jekyll Serve: " state))))))
#+end_src

Я хотел, чтобы одна и та же функция запускала и останавливала локальный
сервер — для удобства. Логика для этого максимально простая:
- Если процесс =jekyll-serve= существует, то убиваем его.
- Если процесса нет — запускаем сервер.

#+begin_src emacs-lisp
(defun org-jekyll--suffix-serve-toggle ()
  "Serve blog or stop serving the blog."
  (interactive)
  (let ((current-path (file-name-directory buffer-file-name)))
    (if (eq (process-status "jekyll-serve") ' run)
        (interrupt-process "jekyll-serve")
      (cd (expand-file-name org-jekyll-paths-base-path))
      (make-process ...)
      (cd current-path))))
#+end_src

** Очистка рабочего каталога Jekyll
:PROPERTIES:
:CUSTOM_ID: jekyll-clean
:END:

Очистка рабочего каталога уже не так проста. Если с вызовом команды =bundle
exec jekyll clean= всё просто — нужен ещё один вызов =make-process=:

#+begin_src emacs-lisp
(make-process
 :name "jekyll-clean"
 :buffer "jekyll-clean"
 :command '("bundle" "exec" "jekyll" "clean")
 :delete-exited-processes t
 :sentinel (lambda (process state)
             (cond
              ((and (eq (process-status process) 'exit)
                    (zerop (process-exit-status process)))
               (message "%s" (propertize "Blog cleaned" 'face '(:foreground "blue"))))
              ((eq (process-status process) 'run)
               (accept-process-output process))
              (t (error (concat "Jekyll Clean: " state))))))
#+end_src


То с результатами работы экспорта из Org Mode всё сложнее — Jekyll о них не
знает и эти файлы останутся в файловой системе. Следовательно, перед вызовом
=jekyll clean= надо бы почистить каталоги =_articles/=, =_static/= и =_post/= от того,
что туда добавила =org-publish-project=. Это я сделал через следующий
S-expression:

#+begin_src emacs-lisp
(mapc (lambda (x)
        (mapc (lambda (file)
                (delete-file file nil))
              (mapcan (lambda (directory)
                        (directory-files-recursively (concat org-jekyll-paths-base-path directory) (cdr x) nil nil nil))
                        (car x))))
      `((("/_posts/en" "/_posts/ru") . "\\.html$")
        (("/assets/static" "/_static") . ,(concat "\\.png\\|\\.jpg$\\|\\.jpeg$"
                                                  "\\|"
                                                  "\\.JPG$\\|\\.svg$\\|\\.webm$"
                                                  "\\|"
                                                  "\\.webp$\\|\\.html$\\|\\.tar.bz2$"
                                                  "\\|"
                                                  "\\.org$\\|\\.gif$\\|\\.gpx$"
                                                  "\\|"
                                                  "\\.uxf$"))
        (("/_articles") . "\\.org$")))
#+end_src

На первый взгляд код может выглядеть переусложнённым, но всё что он делает —
пробегается по заданным каталогам и удаляет из них файлы, подпадающие под
заданное регулярное выражение.

Первая лямбда =(lambda (x) ...)= просто передаёт каждый элемент из основного
списка (например, первый элемент: =(("/_posts/en" "/_posts/ru") . "\\.html$")=)
в следующий S-expression:

#+begin_src emacs-lisp
(mapc (lambda (file)
        (delete-file file nil))
      (mapcan (lambda (directory)
                (directory-files-recursively (concat org-jekyll-paths-base-path directory) (cdr x) nil nil nil))
              (car x)))
#+end_src

Тут уже всё немного сложнее. Второй параметр =mapc= не просто переменная =x= с
переданным элементом списка внутри, а ещё одно S-expression. Оно будет сначала
вычислено и его результат (ещё один список — список файлов), будет поэлементно
обработан последней лямбдой, которая просто удалит файл:

#+begin_src emacs-lisp
(lambda (file)
  (delete-file file nil))
#+end_src

S-expression с =mapcan=[fn:mapcan] делает следующее:
1. Берёт первый элемент списка с путями/регулярками через =(car x)= — это будет
   ещё один список с путями к директориям, например: =("/_posts/en"
   "/_posts/ru")=.
2. В лямбде с =directory-files-recursively= пробегается по этому списку и
   получает список файлов в каталоге, которые подпадают под заданное
   регулярное выражение. Регулярка — последний элемент списка =x= и его можно
   получить через =(cdr x)=.
3. В итоге получается что-то вроде =(("/_posts/en/article1/file.org"
   "/_posts/en/article2/file.org") ("/_posts/ru/article1/file.org"
   "/_posts/ru/article2/file.org"))=. Если бы я использовал =mapc=, то на вход
   лямбда-функции для удаления файлов попал бы список вместо строки с путём к
   файлу и =delete-file= сломался бы.

   Для примера, в следующем коде печатается содержимое переменной =file=,
   которое попадает в лямбду, если бы использовался =mapc=:
   #+begin_src emacs-lisp
   (mapc (lambda (file)
           (print file))
         (mapc (lambda (directory)
                 directory)
               '(("a" "b") ("c" "d"))))

   ("a" "b")
   ("c" "d")
   #+end_src
4. Надо «сплющить» список и этим как раз занимается =mapcan=. Она превращает
   список из предыдущего пункта в: =("/_posts/en/article1/file.org"
   "/_posts/en/article2/file.org" "/_posts/ru/article1/file.org"
   "/_posts/ru/article2/file.org")= — и возвращает результат в качестве второго
   параметра в вышележащий =mapc=.

   Вот пример того, что оказывается на входе лямбды для удаления файлов при
   использовании =mapcan= — уже не список, а отдельные его элементы:
   #+begin_src emacs-lisp
   (mapc (lambda (file)
           (print file))
         (mapcan (lambda (directory)
                   directory)
                 '(("a" "b") ("c" "d"))))

   "a"
   "b"
   "c"
   "d"
   #+end_src

Итоговая функция для очистки рабочего каталога Jekyll выглядит следующим
образом:

#+begin_src emacs-lisp
(defun org-jekyll--suffix-clear ()
  "Clear blog files."
  (interactive)
  (let ((current-path (file-name-directory buffer-file-name)))
    (cd (expand-file-name org-jekyll-paths-base-path))
    (mapc (lambda (x)
            (mapc (lambda (file)
                    (delete-file file nil))
                  (mapcan (lambda (directory)
                            (directory-files-recursively (concat org-jekyll-paths-base-path directory) (cdr x) nil nil nil))
                          (car x))))
          `((("/_posts/en" "/_posts/ru") . "\\.html$")
            (("/assets/static" "/_static") . ,(concat "\\.png$\\|\\.jpg$\\|\\.jpeg$"
                                                      "\\|"
                                                      "\\.JPG$\\|\\.svg$\\|\\.webm$"
                                                      "\\|"
                                                      "\\.webp$\\|\\.html$\\|\\.tar.bz2$"
                                                      "\\|"
                                                      "\\.org$\\|\\.gif$\\|\\.gpx$"
                                                      "\\|"
                                                      "\\.svg$"))
            (("/_articles") . "\\.org$\\|\\.png$")))
    (make-process
     :name "jekyll-clean"
     :buffer "jekyll-clean"
     :command '("bundle" "exec" "jekyll" "clean")
     :delete-exited-processes t
     :sentinel (lambda (process state)
                 (cond
                  ((and (eq (process-status process) 'exit)
                        (zerop (process-exit-status process)))
                   (message "%s" (propertize "Blog cleaned" 'face '(:foreground "blue"))))
                  ((eq (process-status process) 'run)
                   (accept-process-output process))
                  (t (error (concat "Jekyll Clean: " state))))))))
#+end_src

** Интерфейс пользователя (transient)
:PROPERTIES:
:CUSTOM_ID: transient-ui
:END:

Ко всей этой красоте неплохо было бы добавить /удобный для пользователя Emacs/
интерфейс, чтобы не вызывать каждый раз нужную функцию через =M-x=.

Здесь я особо не мудрствовал и просто использовал библиотеку [[https://jd.codes/posts/transient-emacs/][Transient]], как и
[[https://mastodon.social/@fabrik42][Christian Dewein]]. В итоге получилась вот такая штука:

#+CAPTION: Интерфейс панели для работы с блогом
#+ATTR_HTML: :align center :alt Panel with blog actions
[[file:transient_panel.png]]

Ряд суффиксов (функций, которые будут вызываться при выборе соответствующих
пунктов меню) я уже описал выше. Префикс (код, описывающий панель) выглядит
следующим образом:

#+begin_src emacs-lisp
;; Transient keys description:

(transient-define-prefix org-jekyll-layout-descriptions ()
  "Transient layout with blog commands."
  [:description (lambda () (concat org-jekyll-url " control panel" "\n"))
                ["Development"
                 ("b" "Build blog" org-jekyll--suffix-build)
                 ("s" org-jekyll--suffix-serve-toggle
                  :description (lambda () (if (eq (process-status "jekyll-serve") 'run)
                                              "Stop serving local blog"
                                            "Serve local blog")))
                 ("o" "Open served blog" org-jekyll--suffix-open-blog)
                 ("O" "Open blog in Web" org-jekyll--suffix-open-remote-blog)
                 ("B" "Open build log" org-jekyll--suffix-open-build-log)
                 ("l" "Open serve log" org-jekyll--suffix-open-serve-log)
                 ("C" "Clear blog directory" org-jekyll--suffix-clear)]
                ["Actions"
                 ("n" "New blog post" org-jekyll--suffix-create-post)]])

;; Function to call main menu:

(defun org-jekyll-menu ()
  "Open blog control center."
  (interactive)
  (org-jekyll-layout-descriptions))
#+end_src

Функции-суффиксы это обычные функции без параметров, например:

#+begin_src emacs-lisp
(defun org-jekyll--suffix-open-blog ()
  "Open locally served blog."
  (interactive)
  (browse-url "http://127.0.0.1:8000/"))

(defun org-jekyll--suffix-open-remote-blog ()
  "Open remote blog."
  (interactive)
  (browse-url org-jekyll-url))

(defun org-jekyll--suffix-create-post ()
  "Create new blog post."
  (interactive)
  (cd (expand-file-name org-jekyll-paths-base-path))
  (org-jekyll--create-new-post))
#+end_src

В описании пункта для запуска/остановки локального сервера я сделал так, чтобы
он сразу же показывал запущен ли локальный сервер или нет — через проверку
наличия процесса ="jekyll-serve"= в системе.

Отобразить эту панельку можно вызвав функцию =org-jekyll-menu=. Забегая немного
вперёд — эта функция вызывается хоткеем в моём плагине.

** Оформление в виде плагина
:PROPERTIES:
:CUSTOM_ID: emacs-plugin
:END:

Осталось оформить всё как Emacs-плагин — не буду же я каждый раз делать
=eval-buffer=? Пусть Emacs сам подгружает весь нужный код при старте.

Для начала я прогнал исходный код через =M-x checkdoc= и добавил недостающие
комментарии. Потом добавил зависимости в заголовок:

#+begin_src emacs-lisp
(require 'htmlize)
(require 'ox-publish)
(require 'transient)
#+end_src

Здесь: =htmlize= нужен Org Mode для подсветки кода в сгенерированном HTML,
=ox-publish= — расширение для публикации файла средствами Org
Mode. Использование библиотеки =transient= я уже описал выше.

Ещё я добавил =provide= в конец файла:

#+begin_src emacs-lisp
(provide 'org-jekyll)
#+end_src

Ну и описал minor mode, который будет вызывать описанное выше transient-меню
по хоткею =C-c b=:

#+begin_src emacs-lisp
;; Minor mode:

;;;###autoload
(define-minor-mode org-jekyll-mode
  "Enable transient menu to operate with blog-related OrgMode files."
  :lighter " oj"
  :global nil
  :init-value nil
  :keymap (list (cons (kbd "C-c b") #'org-jekyll-menu)))
#+end_src

Теперь, если этот режим включён через =M-x org-jekyll-mode=, то по нажатию на
=C-c b b= собирается блог, по нажатию =C-c b n= создаётся новая статья и так
далее. Если просто нажать =C-c b=, то покажется transient-меню со скриншота
выше.

** Загрузка плагина в Emacs
:PROPERTIES:
:CUSTOM_ID: loading-plugin-in-emacs
:END:

Осталось правильным образом загрузить этот плагин в Emacs, чтобы новый minor
mode сам включался только при открытии файла с постом для блога и не включался
при открытии остальных org-файлов.

Для этого я добавил ещё одну функцию, которая проверяет что мы открыли файл со
статьей в буфере и включает мой minor mode:

#+begin_src emacs-lisp
;;;###autoload
(defun org-jekyll-init ()
  (if (and buffer-file-name
           (string-match "^/.+/article-[[:lower:]]\\{2\\}\\.org" (buffer-file-name)))
      (org-jekyll-mode 1)))
#+end_src

Ну а сам плагин загружается в Emacs через =use-package= следующим образом:

#+begin_src emacs-lisp
(use-package org-jekyll
  :load-path "~/rsync/blog/"
  :ensure nil
  :commands org-jekyll-init
  :hook (org-mode . org-jekyll-init))
#+end_src

Теперь, каждый раз когда открывается org-файл, вызывается функция
=org-jekyll-init=. И если мы открыли файл с текстом для блога, то включается
=org-jekyll-mode= и мой хоткей вместе с transient-меню становятся доступны.

* Исходный код плагина
:PROPERTIES:
:CUSTOM_ID: source-code
:END:

Я не задумывал этот плагин пригодным для использования другими людьми — в
конце концов в нём захардкожена моя структура каталогов со статьями и мои
методы именования файлов. Поэтому я не публиковал его в MELPA и не заводил для
него отдельный репозиторий.

Исходный код лежит в том же репозитории, где и файлы для моего
блога. Посмотреть на него можно [[https://github.com/eugeneandrienko/eugeneandrienko.github.io/blob/master/org-jekyll.el][по этой ссылке]].

В результате, если мне необходимо будет перейти на другой генератор
статических сайтов — достаточно будет подправить функции, участвующие в
экспорте из OrgMode, чтобы сгенерированный HTML подходил к новому движку. Мои
исходники статей и вся структура каталогов для них — останется неизменной.

* Что ещё можно улучшить?
:PROPERTIES:
:CUSTOM_ID: plugin-improvement
:END:

В текущей версии плагина есть несколько моментов, которые определённо стоит
улучшить:
1. Вызов функции =org-publish-project= нужно сделать асинхронным, чтобы он не
   блокировал Emacs при запуске, как сейчас. При этом, =org-publish-project= и
   последующий вызов =make-process= должны работать строго последовательно,
   иначе Jekyll попытается собрать блог когда файлы для сборки ещё не
   подготовлены.
2. =org-publish-project= умеет работать с блоками Org Babel, которые я хочу
   использовать для описания всяких сложных схем в виде кода для [[https://github.com/plantuml/plantuml][PlantUML]]
   прямо в тексте поста. После вызова =org-publish-project= в каталоге
   =_articles/= будут лежать готовые изображения со схемами, сделанными на
   основе PlantUML описаний (см. блогпост [[https://hostsharing.coop/@dzu][@dsu]] с деталями реализации:
   https://blog.lazy-evaluation.net/posts/orgmode-diagrams.html).

   Надо лишь, чтобы функция ~org-jekyll--prepare-static~ умела копировать файлы
   с изображениями из нового места. А функция ~org-jekyll--suffix-clear~ умела
   удалять эти файлы.

   /Уже реализовано — см. коммит [[https://github.com/eugeneandrienko/eugeneandrienko.github.io/commit/e919bd6d2b7f3a0b853fdf71f288f5c9f1749575][e919bd6d2b7f3a0b853fdf71f288f5c9f1749575]]./
   

* Примечания
:PROPERTIES:
:CUSTOM_ID: notes
:END:

[fn:virtue_signaling] Сначала, в середине марта 2022 года, Visa и Master Card
отрезали меня практически от всего, что можно купить за деньги за пределами
страны. Из-за чего я не смог ни перенести свой домен к другому регистратору,
ни оплатить свой VPS в Финляндии.

[fn:namecheap] Это отдельная и совершенно «прекрасная» история. 28 февраля
2022 года NameCheap прислал мне письмо-уведомление о том, что они
разделегируют мой домен через 7 дней потому что я из «неправильной» страны
(это было задолго до запрета оказывать IT-услуги компаниям из санкционного
списка, к которым я и так никоим образом не отношусь — скорее всего рассылка
«писем счастья» шла по адресу регистрации/биллинга ради вышеупомянутого virtue
signaling):

#+ATTR_HTML: :align center :alt Namecheap services discontinuation
[[file:namecheap1.png]]

В следующих двух письмах они продлили срок на две недели. И предложили мне до
дедлайна либо уехать из страны, либо +заняться протестной деятельностью+ сесть в
тюрьму на десяток лет, если я хочу продолжать пользоваться их
услугами🤡. Предполагаю, что эти письма составлял какой-то не особо умный
человек из страны «первого мира», у которого единственное его столкновение с
репрессивным аппаратом заключалось в том, что ему не продали алкоголь без ID
на кассе Wallmart'а; а про жизнь вне своих отлаженных институтов он знает из
серии фильмов «Голодные игры». И который уверен, что эмигрировать просто —
заполняешь какие-то бумажки на таможне при въезде и вжух — ты уже гражданин
другого государства.

#+ATTR_HTML: :align center :alt Namecheap next emails about service shutdown
[[file:namecheap2.png]]

Перенести свой домен к другому регистратору я тогда не успел, из-за того, что
мои карты быстро и внезапно для меня оказались отключены от Visa/MasterCard —
и я не мог заплатить другому регистратору доменных имён за перенос. Через *год
(!)* оказалось, что мой домен по-прежнему обслуживается в NameCheap — после
того как я получил от них письмо с напоминанием занести немного своих
«грязных» денег для продления домена🤡🤡:

#+ATTR_HTML: :align center :alt Namecheap domain renewal
[[file:namecheap3.png]]

Естественно, услугами NameCheap я с тех пор больше не пользуюсь и обхожу его
десятой дорогой, сделав выбор в пользу более вменяемого доменного
регистратора, расположенного как можно дальше (на другой стороне планеты) от
меня. Мораль истории — не стоит доверять корпорациям и всяким централизованным
и закрытым сервисам, которые вы не контролируете. Они выбросят вас не
задумываясь, если им это будет выгодно. Всегда стоит иметь запасной план, на
случай если что-то пойдёт не так.

[fn:jekyll] Он выглядел достаточно простым и в то же время оказался достаточно
популярным и часто использовался (и используется до сих пор) у разных хостеров
в качестве предустановленного приложения для блоггинга.

[fn:javascript] Не нравится мне JS, к тому же без него блог невообразимо
быстро открывается и работает на моём Thinkpad X220.

[fn:org-publish-project] https://orgmode.org/worg/org-tutorials/org-publish-html-tutorial.html

[fn:clojure] Во времена учёбы в университете я немного интересовался Lisp'ом,
почитывал «Structure and Interpretation of Computer Programs» и писал разные
простенькие программки на Clojure. Исходный код некоторых из них сохранился до
сих пор:
- https://github.com/eugeneandrienko/jamendo-client
- https://github.com/eugeneandrienko/cs-alias-clj

[fn:defcustom] https://www.gnu.org/software/emacs/manual/html_node/eintr/defcustom.html

[fn:quoting] См. https://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html
и https://www.gnu.org/software/emacs/manual/html_node/elisp/Backquote.html

[fn:directory-files-recursively] https://www.gnu.org/software/emacs/manual/html_node/elisp/Contents-of-Directories.html#index-directory_002dfiles_002drecursively

[fn:seq-filter] https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequence-Functions.html#index-seq_002dfilter

[fn:mapc] https://www.gnu.org/software/emacs/manual/html_node/elisp/Mapping-Functions.html#index-mapc

[fn:lang_code] Отдельный каталог для каждого языка нужен для плагина
[[https://github.com/untra/polyglot][jekyll-polyglot]], который предоставляет свободный от JavaScript способ
публиковать одну и ту же статью на разных языках.

[fn:regex-search] https://www.gnu.org/software/emacs/manual/html_node/elisp/Regexp-Search.html

[fn:let-star] https://www.gnu.org/software/emacs/manual/html_node/elisp/Local-Variables.html#index-let_002a

[fn:toc-org] Мои настройки для плагина toc-org, с которыми он начинает
понимать тег =:TOC_2_blog:= и генерирует ссылки на разделы, правильно
обрабатываемые при экспорте в HTML:

#+begin_src emacs-lisp
(use-package toc-org
  :pin melpa
  :hook (org-mode . toc-org-mode)
  :config
  (defun toc-org-hrefify-blog (str &optional hash)
    (concat "* " (toc-org-format-visible-link str))))
#+end_src

[fn:plist-get] https://www.gnu.org/software/emacs/manual/html_node/elisp/Plist-Access.html#index-plist_002dget

[fn:make-process] https://www.gnu.org/software/emacs/manual/html_node/elisp/Asynchronous-Processes.html#index-make_002dprocess

[fn:message] https://www.gnu.org/software/emacs/manual/html_node/elisp/Displaying-Messages.html#index-message

[fn:propertize] https://www.gnu.org/software/emacs/manual/html_node/elisp/Changing-Properties.html#index-propertize

[fn:mapcan] https://www.gnu.org/software/emacs/manual/html_node/elisp/Mapping-Functions.html#index-mapcan
